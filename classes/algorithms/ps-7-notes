1a : Let w(u,v) = 1 - lg (r(u,v)) and find the shortest path.

1b : First, represent each currency as a vertex.  Then add an edge
from every vertex to every other.  w(u,v) = 1 - lg (r(u,v)) and use
bellman-ford to determine if a negative weight cycle exists.

2a: Create a graph with a vertex for every city, and an edge between
cities a and b with weight W[a,b].  Then find the shortest path
between the Boston vertex and the Seattle vertex. The total path
length will be the total cost, so the shortest path will be the
solution with the lowest cost.  This takes time O(E + V lg V) = O(n^2)
with D's algo.

2b.  Create a graph with n^2 + 2 vertices, designate one a start and
one an end vertex.  Add an edge from the start vertex to every square
that you could start on, with weight of the cost of that square.  Add
0-weight edges from every square in the last row to the end vertex.
Add edges for any legal move, with weight of the cost of that move.
Then the optimal solution corresponds to the shortest path from the
start to the end vertex.  That path will have length corresponding to
the cost, so the shortest path will have the lowest possible cost.
This will take O(E + V lg V) = O(n^3) time.

4 : Find the maximum flow in the graph.  Then label every edge with
the amount of flow on that edge in the maximal flow.  Remove all edges
with 0 flow.  Then find the edge with the lowest flow on that edge.
Call that amount of flow k.  There must be a k-augmenting path in the
graph.  That is the first path in the sequence.  Remove the flow along
that path from the graph.  Then remove all the 0-flow edges.  This
must remove at least one edge.  Repeat the process.  Since each step
removes at least one edge, there are at most |E| of these paths.  

5 : First, give every edge weight 1.  Pick a start vertex.  Then find
the max flow to every other vertex.  Take the minimum of all the
maximal flows found.  This is the minimum cut for any pair of vertices
in the graph (since it's undirected) and thus the edge-connectivity of
the graph.

9b: Since any sum of bin sizes is integral, if we could find a smaller
solution, it must be < S.  But this is impossible, since the some bin
must have more than 1 total weight, by a counting argument.

9c: Imagine that the solution given by the first-fit heuristic left 2
bins less than half full.  One of these bins must be later in the
list.  When the final item was placed into that bin, it would have
also fit into the earlier less than half full bin.  So this solution
could not have been produced by the first fit method.

9d: Imagine a solution that used more than ciel(2S) bins.  Then more
than half of the bins must be less than half full, since if half were
at least half full, that would exhaust the entire supply of items.
But since there are at least 2 bins, at least 2 must be less than half
full.  But this is impossible by part c.

9e: Since ciel(2S) > 2*ciel(S) >= 2*optimal, the first fit heuristic
is a 2-approximation algorithm.

9f: We can implement this with a simple linked list of bins, adding
new bins on the end if needed.  Then if there are n items, we use at
most n bins.  Since each insertion may look at up to n bins, the total
running time is O(n^2).
