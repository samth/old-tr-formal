\documentclass[twoside]{amsart}
\usepackage{geometry}
\usepackage{stmaryrd}
\usepackage{cancel}
\usepackage{clrscode}
\usepackage{textcomp}
\geometry{tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
\usepackage[curve]{xypic}

\newsavebox{\fmbox}
\newenvironment{fmpage}[1]
{\begin{lrbox}{\fmbox}
   \begin{minipage}{#1}}
{\end{minipage}
\end{lrbox}\fbox{\usebox{\fmbox}}}

\newenvironment{directive}{\begin{fmpage}{5.5in}}{\end{fmpage}}
\newenvironment{problem}[1]{\newpage\section{#1}\begin{fmpage}{5.5in}}{\end{fmpage}}
 
\newtheorem{prop}{Proposition}
\newtheorem{claim}[prop]{Claim}
\newtheorem{lemma}[prop]{Lemma}

\begin{document}

{\raggedleft
Sam Tobin-Hochstadt \\
CSG 713 Final Exam \\
\today \\
{\tt samth@ccs.neu.edu} \\
}

%\newcommand{\min}[#1]{\textrm{min}(

\section*{Problem 1}

First, initialize min($v_1$) to $v_1$.  Then, for each successive
vertex $v_k$, perform BFS from that vertex.  If a previously finished
vertex $v_j$ is reached, then do not follow any vertices from that
point, and tenatively set min($v_k$) = min($v_j$). Continue the BFS
until either the graph is exhausted, or all unvisited vertices have
been previously finished.  Each time a new finished vertex $v_l$ is
encountered, make min($v_l$) the new minimum for $v_k$ if it is lower
than the current minimum.  Therefore, min($v_k$) will be the smallest
index previously visited that is reachable from $v_l$. After
performing this for all vertices, each vertex will have the correct
minimum associated with it.


This algorithm visits every vertex at least once, obviously.  It also
never visits a previously-visited edge, since it does not pursue BFS
past the point where it finds a previously-visited vertex, and a
previously visited edge must connected two previously-unvisited
vertexes.  Therefore, it cannot visit any more than $E$ edges.
Therefore, the total time must be $O(V+E)$. \qed

\section*{Problem 2}

\subsection*{Part i}
This conjecture is false.  No execution of Breadth-First search can
give the minimal spanning tree of this graph.

\[\xymatrix{
  v_1 \ar@{-}[d]_{100} \ar@{-}[r]^1 \ar@{-}[dr]^1 & v_2 \ar@{-}[d]^{100} \\
  v_3 \ar@{-}[r]^1 & v_4
}\]

Any execution of BFS must begin at one of the four vertices.  It must
then visit all of the edges incident on that vertex.  For any vertex,
that includes one of the edges weighted 100.  Thus, that execution
cannot produce the minimal spanning tree. \qed

\subsection*{Part ii}
This conjecture is false. No execution of Depth-First search can
produce the minimal spanning tree of this graph.

\[\xymatrix{
  v_1 \ar@{-}[rr]^{100} \ar@{-}[ddr]_{100} \ar@{-}[dr]^1  & \txt{} & v_2 \ar@{-}[ddl]^{100}
  \ar@{-}[dl]_1    \\
  \txt{} & v_3 \ar@{-}[d]^1   & \txt{} \\
  \txt{} & v_4    & \txt{} 
}\]

There are two cases.  One, the DFS starts at the center ($v_3$).  Then it
moves to one of the other vertices (WLOG $v_1$), and it encounters an
edge weighted 100 to $v_2$, which has not yet been visited.
Therefore, that edge will be included in the final spanning tree, and
the tree will not be minimal.

In the other case, the DFS starts on one of the edge vertices (WLOG
$v_1$).  Either it begins with one of the outer edges, in which case
the tree cannot be minimal.  Otherwise, it moves to $v_3$, and
then to one of the other outer vertices (WLOG $v_2$).  Then there is
an edge to $v_4$, which is not yet explored, so that edge is taken.
Therefore, the tree will not be minimal. \qed

\section*{Problem 3}

\subsection*{Part i}

All MSTs are MMSTs.  Consider the heaviest edge in the MST.  Then
removing that edge divides the tree into two trees.  Now, the edge
must be the lightest edge connecting those two trees.  Consider the
other edges in the graph that connect those trees.  If they exist,
they must be heavier than the edge in the MST.  Therefore, the MST
cannot have a lighter heaviest edge.  Otherwise, there is no other
edge connecting those two trees.  Therefore, that edge must be in any
spanning tree, in particular the MMST.  \qed

\subsection*{Part ii}

Not all MMSTs are MSTs.  This graph:

\[\xymatrix{
  v1 \ar@{-}[r]^2 \ar@{-}[d]_2 & v2 \\
  v3 \ar@{-}[r]_1 & v4 \ar@{-}[u]_1
}\]

has the following MMST:

\[\xymatrix{
  v1 \ar@{-}[r]^2 \ar@{-}[d]_2 & v2 \\
  v3  & v4 \ar@{-}[u]_1
}\]

but this is an MST with less total weight.

\[\xymatrix{
  v1 \ar@{-}[r]^2  & v2 \\
  v3 \ar@{-}[r]_1 & v4 \ar@{-}[u]_1
}\]

\qed


\section*{Problem 4}

The Laksurk method successfully finds a minimum spanning tree for any
graph.  To show this, assume that there is some graph for which this
is not true.  Then there must be some edge in the graph produced which
is not in the MST.  Call this edge $e$.  Removing $e$ separates the
tree into two parts.  Therefore, the MST must have an edge between
these two trees.  But if there was a lighter edge between those two
trees, it would have replaced $e$ in the course of the Laksurk
method.  Therefore, $e$ cannot exist.  Thus the Laksurk method
produces the minimal spanning tree. \qed

\section*{Problem 5}

First, compute all pairs shortest paths for the graph.  By repeated
application of Dijkstra's algorithm, this can be accomplished in
$O(V^3)$ time.  Then, for each vertex $v_i$, iterate through all
vertices $v_j$ and compute the sum of the shortest path $v_i \leadsto v_j +
v_j \leadsto v_i$.  Find the minimum such sum, and store it for that
vertex.  Then find the mimumum of these sums over all vertices in the
graph.  This is the minimum weight cycle for the entire graph.

This process involves $O(V^3)$ preprocessing, and then $O(V)$ work for
each of the $V$ nodes in the graph, so it runs in $O(V^3 + V^2) =
O(V^3)$ time.  \qed


\section*{Problem 6}

\subsection*{Part i}

Create a graph with a start vertex, an end vertex, and vertex
$v_{x_i}$ for every number $x_i$.  Add an edge from the start vertex
to every vertex except the end vertex.  Add a 0-weight edge from every
vertex except the start vertex to the end vertex.  Then weight the
edge from the start vertex to each $v_{x_i}$ with weight $-x_i$.  Then
add an edge $(v_{x_i}, v_{x_{i+1}}$ with weight $-x_{i+1}$ for vertices
$v_{x_1}$ to $v_{x_{n-1}}$.  

This creates a graph with $n+2$ vertices and $n + n + n-1 = 3n-1$
edges.

Then we simply use DAG-SP to compute the shortest path from the start
to then end vertex.  This takes time $O(V+E) = O(n)$.  This shortest
path will have weight $\sigma_{k=i}^j -x_k$ for all the $v_{x_k}$ that
it passes through.  But minimizing this sum corresponds exactly to
maximizing  $\sigma_{k=i}^j x_k$.  Therefore, the shortest path is the
sequence of numbers that maximizes $S(i,j)$.

\subsection*{Part ii}

Create a vertex for every number in the sequence.  Create a single end
vertex. Then create an edge from every vertex to the end vertex.  Then
create a start vertex with and edge to every other vertex.  

Then create edges from a number to every number in the sequence that
is later in the sequence and larger.  This requires iterating through
the sequence once for each element, which requires $O(n^2)$ time.

Then we merely need to find the longest path from the start vertex to
the end vertex.  While this problem is NP-complete in general, our
graph is very simple. 

First, compute the inverse of the graph.  Then begin at the end
vertex.  Perform BFS.  When each vertex is reached, record the number
of links followed thus far to get to that vertex.  If the number is
greater than the value currently stored at that vertex, then update
the value to the larger one, and continue with BFS, even though the
vertex was already discovered.  Also record the vertex from which this
vertex was reached.  When we complete, we will have a record of the
longest path in the graph.  To compute the answer, begin at the start
vertex.  Then add the number represented by the vertex stored at the
start vertex.  Then add the vertex stored at that vertex, and so on.
Eventually the end vertex will be reached, and we will have output the
entire longest list. 

This requires processing of every edge and every vertex, and thus take
$O(V+E) = O(n+n^2) = O(n^2)$ time.

\qed

\section*{Problem 7}

\subsection*{Part i}

Given the max flow in $G$, determine the residual network.  This is
easily computed by subtracting the flow on each edge from the capacity
of that edge.  This takes time $O(E)$.  

This produces a disconnected graph, by the Max-Flow/Min-Cut theorem.
As stated in the problem, we can assume that every edge in this new
residual network has integral capacites, which means that all the
remaining edges have capacity 1.

Then add the new edge $e'$ to this residual network.  If there is a
path from the source to the sink with this addition, then there must
an augmenting path of capacity 1 in the residual network, and the new
flow is $|f| + 1$. We can then update the flow with the new augmenting
path in $O(E)$ time.  Otherwise, there is no new augmenting path, and
the new flow is the same as the old flow. Since we can compute
reachability in $O(V+E)$ time, the entire algorithm runs in $O(V+E)$
time. \qed


\subsection*{Part ii}

Given the max flow in $G$, determine the residual network.  This is
easily computed by subtracting the flow on each edge from the capacity
of that edge.  This takes time $O(E)$.  

This produces a disconnected graph, by the Max-Flow/Min-Cut theorem.
As stated in the problem, we can assume that every edge in this new
residual network has integral capacites, which means that all the
remaining edges have capacity 1.

Then, determine if the edge $e$ is in the residual network.  If it is,
then it must not be used in the maximal flow, and removing it does not
change the flow.  If it is not, then it must be used in the maximal
flow.  

\section*{Problem 8}

The optimal cut has size at most $|E|$.  There are two kinds of
edges in the result produced by the algorithm: edges within $A$ or
within $B$ and edges between $A$ and $B$.  Call the size of the former
set $x$, and the size of the latter set $y$.  On each iteration of the
algorithm, we have a new $x'$ and $y'$.  But because of the test in
the algorithm, $x' - x <= y' - y$.  Therefore, since $x$ starts of
smaller than $y$ (since there are no self-loops), $y$ must always be
greater than $x$.  Therefore, at least half of the edges must be
between $A$ and $B$.  Therefore, the cut must be at least half as big
as optimal.  \qed 

To see that an approximation ratio of 2 is tight, consider the
following graph:

\[\xymatrix{
  v_1 \ar@{-}[r] & v_3 \ar@{-}[r] & v_2
}\]

Then $A$ and $B$ will be initialized, and there will only be one
remaining vertex.  Since $d(v_3,\{v_1\}) = d(v_3,\{v_2\}) = 1$, $v_3$
will be allocated to $B$.  This produces a cut of size 1.  However,
the maximal cut is $(\{v_1,v_2\},\{v_3\})$, which has size 2.

\end{document}
