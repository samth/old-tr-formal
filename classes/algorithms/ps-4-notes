Problem 1a:

Greedy selection of shortest.  Sort first.  Running time n log n +
size of solution.

Problem 1b: Apply 0-1 knapsack.  each song's value = weight = length

Problem 2a: Select furthest gas station that can be reached from the
current station.

Problem 2b: Select the interval that covers the most points.  Repeat.

Problem 3: The greedy algorithm is to select the most of c^k, then
c^k-1, etc.  This is correct since the any different selection of c^l
could be replaced by c^(l+1) if there are more than c of them, which
the greedy algorithm would select.

Problem 5a: 

Problem 5b: Add an additional 1 cost to each operation, and put it in
an account.  Subtract 1 from this account each time a 1 is flipped
that doesn't have a $ attached.  If n = Om(b) then the account will
end up with a positive value.  

Problem 6: 

Implementation: regular heap, but reverse the heap property.

Analysis: Add 1 to each insertion and for each node above it.  Then
when removing, there is a dollar on each node for moving it up.

Problem 7: 
Implementation: each enqueue, push on stack 1.  each dequeue, pop all
elements and push onto stack 2.  pop and return.  move all back to
stack 1.  

Accounting: cost of 5 per enqueue.  One for push, 2 to pop and push
onto stack 2, 2 to pop and push back to stack 1

Potential: size of stack 1

Other probs:  increment chapter, execpt 4 and 8
