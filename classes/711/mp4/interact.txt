Welcome to DrScheme, version 205.3-cvs3oct2003.
Language: Essentials of Programming Languages (2nd ed.).
test-harness.scm: unified test harness for CSG 711 2003-08-18 12:21
test-suite.scm: unified test suite for CSG 711 2003-08-18 12:21
base/env.scm larger illustrative language 2003-09-18 21:05
> (run-all)
test: pgm3-1-1
1
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: pgm3-1-2
add1(x)
correct outcome: error
actual outcome:  error
correct

test: test3-1-unbound-variable
foo
correct outcome: error
actual outcome:  error
correct

test: true-exp
true
correct outcome: #t
actual outcome:  #(struct:bool-val #t)
correct

test: if-true
if zero?(0) then 3 else 4
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: if-false
if zero?(1) then 3 else 4
correct outcome: 4
actual outcome:  #(struct:num-val 4)
correct

test: pgm5
let x = 3 y = 4 in +(x,y)
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

test: let-1
let x = 5 y = 6 in +(x,y)
correct outcome: 11
actual outcome:  #(struct:num-val 11)
correct

test: let-to-proc-1
(proc (x,y) +(x,y) 5 6)
correct outcome: 11
actual outcome:  #(struct:num-val 11)
correct

test: nested-let-1

let z = 5 x = 3
in let x = 4
       y = +(x,z)         % here x = 3
   in *(z, +(x,y))        % here x = 4
correct outcome: 60
actual outcome:  #(struct:num-val 60)
correct

test: nested-let-as-proc

(proc (z,x)
 (proc (x,y) *(z, +(x,y)) 4 +(x,z))
 5 3)

correct outcome: 60
actual outcome:  #(struct:num-val 60)
correct

test: nested-let-3
let z = let x = 3 in *(x,x) in z
correct outcome: 9
actual outcome:  #(struct:num-val 9)
correct

test: bind-a-proc
let f = proc(x,y)+(x,y) in (f 3 4)
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

test: apply-a-proc
(proc(x,y)-(x,y)  4 3)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: infinite-loop

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
in let loop = (fix proc (f,x) (f x))
   in (loop 1)
test skipped

test: poor-mans-letrec

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
    t4m = proc (f,x) if zero?(x) then 0 else +(4,(f -(x,1)))
in let times4 = (fix t4m)
   in (times4 3)
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: fact-of-6
letrec
fact = proc (x) if zero?(x) then 1 else *(x, (fact sub1(x)))
in (fact 6)
correct outcome: 720
actual outcome:  #(struct:num-val 720)
correct

test: odd-of-13
letrec
even = proc (x) if zero?(x) then 1 else (odd sub1(x))
odd  = proc (x) if zero?(x) then 0 else (even sub1(x))
in (odd 13)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: ho-nested-letrecs
letrec even = proc (odd,x) if zero?(x) then 1 else (odd sub1(x))
           in letrec  odd = proc (x) if zero?(x) then 0 else (even odd sub1(x))
           in (odd 13)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: let*-1
let* x = 1 y = x x = 2 in +(x,y)
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: let*-2
let* x = 1 in let* y = 4 x = 2 in +(x,y)
correct outcome: 6
actual outcome:  #(struct:num-val 6)
correct

test: let*-3
let* x = 1 in x
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: let*-4
let* x = 1 in let x = 2 in x
correct outcome: 2
actual outcome:  #(struct:num-val 2)
correct

test: let*-5
let* x = proc (x,y) +(x,y) y = (x 3 4) in y
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

no bugs found
> 