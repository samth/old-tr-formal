Discussion
-------------

Interesting result 1:

(analyze "let x = proc(y) y in (x 4)")

((0 : (let (x) ((1 : (proc-exp y (3 : #(struct:var-exp y))))) 
           (2 : (app-exp (4 : #(struct:var-exp x)) (5 :
		#(struct:const-exp 4)))))) 

 (phi: ((0 (5)) (1 (1)) (2 (5)) (3 (5)) (4 (1)) (5 (5)) (x (1)) (y
(5))) flow: ((3 2) (5 y) (1 x) (2 0) (y 3) (x 4))))

We see that phi(5,0) is deduced.  This demonstrates that the analyzer
knows that the ultimate value of the program is 4, despite this being
passed through a procedure.  So, although the ultimate output of
procedures is not decideable in general, in the case of a simple
identity function, 0CFA gets all the possible analysis.  

Interesting result 2:

(analyze "letrec a = proc(y) if y then 3 else 4 b = (a true) in (b
4)")

correctly determines that the only possible value of the entire
expression is an error.  


Interesting results 3:

(analyze "letrec a = proc(y) if y then proc(x) x else 4 b = (a true)
in (b 4)")

correctly determines that (error 4) are the two possible values of the
entire expression.

Interesting result 4:

(analyze 
"letrec mul4 = proc(x) if zero?(x) then 0 else +(4, (mul4 -(x,1))) 
in (mul4 3)")

compared to 

(analyze 
"let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
    t4m = proc (ff,xx) if zero?(xx) then 0 else +(4,(ff -(xx,1)))
in let times4 = (fix t4m)
   in (times4 3)
"
)

produce surprisingly similar analyses.  For example, both show that
the final value is produced either by the + or the 0.  It's fairly
impressive that 0CFA is able to deduce this despite the multiple
layers of indirection in the second code fragment.  

[The actual analysis is available upon request.]

Timing Results
----------------

I timed two different types of programs, at varying sizes.

Type 1: let ... x_n = +(3,4) ... in x_0
n is number of let bindings

Type 2: let x = +(3,+(3, .... )) in x
n is number of 3's 

For each program I timed (analyze) on the program with 
n = {1,5,10,30,50,70,90,120,150,300}

The data is as follows (real time output from (time (analyze)))

((1 46 18) (5 276 78) (10 566 156) (30 3071 710) (50 8278 1695) 
(70 15534 3196) (90 26672 5415) (120 46523 9688) (150 73849 15140) 
(300 303051 60972))

I plotted both sets of points (see attached).  

Also, I attempted to fit curves to each set of points.  

The first fit quite closely to y = 1.2 * n^2.2. 
The second fit to y = 0.22 * n^2.2.

The curves are also plotted on the attached sheet.  

These results were quite surprising.  I expected the performance of
analyze to be worse, not better, than n^3.  

Semantics for 0CFA extension to base
--------------------------------------

New kinds of assertions:

(IF l l1 l2 l3) |
(LET l l1) |
(BIND l x)

New formulas:

bind(l,x) => flow(l,x)

let(l,l') => flow(l',l)

if(l,l1,l2,l3) => flow(l2,l) & flow(l3,l)

There are no new rules for function abstraction or application, since
these are handled by automatically currying all functions of more than
one argument during the labeling process.  

Sadly, this makes it impossible to discover arity errors in the flow
analyzer.  But that's what types are for.  :-)

Error Propagation
------------------

Evaluation rules for errors:

(x,p) V error     (y,p) V w
----------------------------
    (prim(x,y),p) V error

(x,p) V error     (y,p) V w
----------------------------
    (prim(y,x),p) V error

(x,p) V error     (y,p) V w
----------------------------
    ((x y),p) V error

(x,p) V error     (y,p) V w
----------------------------
    ((y x),p) V error

(x,p) V (closure-val)     (y,p) V w
----------------------------
    (prim(x,y),p) V error

(x,p) V (closure-val)     (y,p) V w
----------------------------
    (prim(y,x),p) V error

(x,p) V const   (y,p) V w
----------------------------
    ((x y),p) V error

0CFA formulae for errors:

phi(error,l1) & app(l,l1,l2) => phi(error,l)
phi(error,l2) & app(l,l1,l2) => phi(error,l)
phi(error,l1) & prim(l,l1,l2) => phi(error,l)
phi(error,l2) & prim(l,l1,l2) => phi(error,l)
phi((abs l3 x l4),l1) & prim(l,l1,l2) => phi(error,l)
phi((abs l3 x l4),l2) & prim(l,l1,l2) => phi(error,l)
phi((const l),l2) & (app l1 l2 l3) => phi(error,l1)
