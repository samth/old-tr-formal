Welcome to DrScheme, version 205.3-cvs3oct2003.
Language: Essentials of Programming Languages (2nd ed.).
mutable-pairs/ceks.scm 2003-10-05 12:57
implicit-store/lang.scm 2003-10-05 11:59
test-harness.scm: unified test harness for CSG 711 2003-08-18 12:21
test-suite.scm: unified test suite for CSG 711 2003-08-18 12:21
explicit-store/store2.scm: store as a Scheme vector 2003-10-04 19:16
mutable-pairs/pairval2.scm 2003-10-05 12:55
> (run-all)
test: pgm3-1-1
1
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: pgm3-1-2
add1(x)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: test3-1-unbound-variable
foo
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: true-exp
true
correct outcome: #t
actual outcome:  #(struct:bool-val #t)
correct

test: if-true
if zero?(0) then 3 else 4
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: if-false
if zero?(1) then 3 else 4
correct outcome: 4
actual outcome:  #(struct:num-val 4)
correct

test: pgm5
let x = 3 y = 4 in +(x,y)
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

test: let-1
let x = 5 y = 6 in +(x,y)
correct outcome: 11
actual outcome:  #(struct:num-val 11)
correct

test: let-to-proc-1
(proc (x,y) +(x,y) 5 6)
correct outcome: 11
actual outcome:  #(struct:num-val 11)
correct

test: nested-let-1

let z = 5 x = 3
in let x = 4
       y = +(x,z)         % here x = 3
   in *(z, +(x,y))        % here x = 4
correct outcome: 60
actual outcome:  #(struct:num-val 60)
correct

test: nested-let-as-proc

(proc (z,x)
 (proc (x,y) *(z, +(x,y)) 4 +(x,z))
 5 3)

correct outcome: 60
actual outcome:  #(struct:num-val 60)
correct

test: nested-let-3
let z = let x = 3 in *(x,x) in z
correct outcome: 9
actual outcome:  #(struct:num-val 9)
correct

test: bind-a-proc
let f = proc(x,y)+(x,y) in (f 3 4)
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

test: apply-a-proc
(proc(x,y)-(x,y)  4 3)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: infinite-loop

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
in let loop = (fix proc (f,x) (f x))
   in (loop 1)
test skipped

test: poor-mans-letrec

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
    t4m = proc (f,x) if zero?(x) then 0 else +(4,(f -(x,1)))
in let times4 = (fix t4m)
   in (times4 3)
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: fact-of-6
letrec
  fact = proc (x) if zero?(x) then 1 else *(x, (fact sub1(x)))
  in (fact 6)
correct outcome: 720
actual outcome:  #(struct:num-val 720)
correct

test: odd-of-13
letrec
         even = proc (x) if zero?(x) then 1 else (odd sub1(x))
         odd  = proc (x) if zero?(x) then 0 else (even sub1(x))
       in (odd 13)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: ho-nested-letrecs
letrec even = proc (odd,x) if zero?(x) then 1 else (odd sub1(x))
   in letrec  odd = proc (x) if zero?(x) then 0 else (even odd sub1(x))
   in (odd 13)
correct outcome: 1
actual outcome:  #(struct:num-val 1)
correct

test: gensym-test
let g = let count = 0 in proc() 
                        let d = set count = add1(count)
                        in count
in +((g), (g))
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: even-odd-via-set

let x = 0
in letrec even = proc () if zero?(x) then true
                         else let d = set x = sub1(x)
                              in (odd)
          odd  = proc () if zero?(x) then false
                         else let d = set x = sub1(x)
                              in (even)
   in let d = set x = 13 in (odd)
correct outcome: #t
actual outcome:  #(struct:bool-val #t)
correct

test: gensym-using-mutable-pair-left
let g = let count = pair(0,0) in proc() 
                        let d = setleft(count,add1(left(count)))
                        in left(count)
in +((g), (g))
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: gensym-using-mutable-pair-right
let g = let count = pair(0,0) in proc() 
                        let d = setright(count,add1(right(count)))
                        in right(count)
in +((g), (g))
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: begin1
begin 3 ; 4 end
correct outcome: 4
actual outcome:  #(struct:num-val 4)
correct

test: begin2
begin 3 end
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: begin3
let x = 3 in begin let x = 4 in x ; x end
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: begin4
begin end
correct outcome: 0
actual outcome:  #(struct:num-val 0)
correct

test: begin5
let x = 3 in begin set x = 4; x end
correct outcome: 4
actual outcome:  #(struct:num-val 4)
correct

test: array1
let a = array(2)
p = proc (x)
let v = arrayref (x,1)
in arrayset(x,1,add1(v))
in begin
arrayset(a,1,0);
(p a);
(p a);
arrayref(a,1)
end
correct outcome: 2
actual outcome:  #(struct:num-val 2)
correct

test: array2
let x = array(2) in arrayref(x,1)
correct outcome: 0
actual outcome:  #(struct:num-val 0)
correct

test: array3
let x = array(2) in begin arrayset(x,1,2) ; arrayref(x,0) end
correct outcome: 0
actual outcome:  #(struct:num-val 0)
correct

test: try1
let x = (1 2) in x
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: try2
let y = 3 x = (1 2) in x
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: try3
(proc (x,y) 3 (1 2) 4)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: try4
try (proc (x,y) 3 (1 2) 4) recover-from-errors-with 12
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: try5
(1 2)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: try6
try (1 2) recover-from-errors-with 12
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: try8
+(3,(1 2))
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: try7
let x = 4
in letrec
    loop = proc (x) (loop add1(x))
   in
    try 3
    recover-from-errors-with (loop x)
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: try9
(proc (x) y 3)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint1
let x = (1 2) in x
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint2
let y = 3 x = (1 2) in x
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint3
(proc (x,y) 3 (1 2) 4)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint4
checkpoint (proc (x,y) 3 (1 2) 4) recover-from-errors-with 12
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: checkpoint5
(1 2)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint6
checkpoint (1 2) recover-from-errors-with 12
correct outcome: 12
actual outcome:  #(struct:num-val 12)
correct

test: checkpoint8
+(3,(1 2))
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: checkpoint7
let x = 4
in letrec
    loop = proc (x) (loop add1(x))
   in
    checkpoint 3
    recover-from-errors-with (loop x)
correct outcome: 3
actual outcome:  #(struct:num-val 3)
correct

test: checkpoint9
(proc (x) y 3)
correct outcome: 99
actual outcome:  #(struct:num-val 99)
correct

test: cp10
let x = 5 in checkpoint begin set x = 6 ; (2 3) end recover-from-errors-with x
correct outcome: 5
actual outcome:  #(struct:num-val 5)
correct

test: try10
let x = 5 in try begin set x = 6 ; (2 3) end recover-from-errors-with x
correct outcome: 6
actual outcome:  #(struct:num-val 6)
correct

test: more-array
let x = array(2) in begin arrayset(x,1,7); arrayref(x,1) end
correct outcome: 7
actual outcome:  #(struct:num-val 7)
correct

no bugs found
> 