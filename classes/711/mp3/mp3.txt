* New Context rules:

cond E => e_1
     .
     .
     e_n => e_n+1		CXT Cond

cons (E, e1)			CXT Cons1
cons (v, E)			CXT Cons2
car (E)				CXT Car
cdr (E)				CXT Cdr

let* x = E ... x = e in e CXT Let*

* New values:

v ::= n | proc (x_1 .. x_n) e | nil | cons (v, v)

* New small-step reductions

RED Cond True
cond true => e_1 ... e_n => e_n+1 end -> e_1

RED Cond Empty
cond {} end -> 0

RED Cond False
cond false => e_1 e2 => e3 ... end -> cond e2 => e3 ... end

RED Car
car (cons (v_1 v_2)) -> v_1

RED Cdr
cdr (cons (v_1 v_2)) -> v_2

RED Let*
let* x1 = v1 x2 = e2 ... xn = en in e0 ->
     let x1 = v1 in let* x2 = e2[v1/x1] ... xn = en[v1/x1] in e0

RED Let*  Empty
let* in e0 -> let in e0


* New Big Step Evaluation Rules

EVAL Cond True
e0 V true	e1 V v
-------------------------------
cond e0 => e1 ... end V v


EVAL Cond False
e0 V false	cond e2 => e3 ... end V v
------------------------------------------------------
cond e0 => e1 e2 => e3 ... end V v 

EVAL Cond Empty

---------------------
cond end V 0

EVAL Car 
e V cons v1 v2
--------------------
car e V v1

EVAL Cdr 
e V cons v1 v2
--------------------
cdr e V v1

EVAL Let*
e_0 V v_0
e_i[v_j/x_j] j=1...i-1 V v_i
e[v_j/x_j] j=1...n V v
--------------------------------------------- 
let* x0 = e0 ... x_n = v_n in e V v


* New Substitution Rules (assuming the previous substitution rules were extended to cover the base language)

(let* in e)[e'/x] = e[e'/x]
(let* x1 = e1 x2 = e2 ... in e)[e'/x] = (let x1 = e1[e1/x] in let* x2 = e2 ... in e)
(let* x1 = e1 x2 = e2 ... in e)[e'/y] = (let x1 = e1[e1/x] in (let* x2 = e2 ... in e)[e'/y])

cons, car, cdr, nil? should be treated just like any other lambda abstraction for the purposes of substiution

(cond t1 => e1 t2 => e2 ... end) [e'/x] = cond t1[e'/x] => e2[e'/x] t2[e'/x] => e2[e'/x] end
