Welcome to DrScheme, version 205.2-cvs1aug2003.
Language: Essentials of Programming Languages (2nd ed.) custom.
test-harness.scm: unified test harness for CSG 711 2003-08-18 12:21
test-suite.scm: unified test suite for CSG 711 2003-08-18 12:21
base/lang.scm larger illustrative language 2003-09-17 16:38
base/reductions.scm 2003-09-17 16:37
base/lang.scm larger illustrative language 2003-09-17 16:38
base/reductions.scm 2003-09-17 16:37
base/bigstep.scm 2003-09-17 16:38
test: pgm3-1-1
1
correct outcome: 1
actual outcome:  #(struct:const-exp 1)
correct

test: pgm3-1-2
add1(x)
correct outcome: error
actual outcome:  error
correct

test: test3-1-unbound-variable
foo
correct outcome: error
actual outcome:  error
correct

test: true-exp
true
correct outcome: #t
actual outcome:  #(struct:true-exp)
correct

test: if-true
if zero?(0) then 3 else 4
correct outcome: 3
actual outcome:  #(struct:const-exp 3)
correct

test: if-false
if zero?(1) then 3 else 4
correct outcome: 4
actual outcome:  #(struct:const-exp 4)
correct

test: pgm5
let x = 3 y = 4 in +(x,y)
correct outcome: 7
actual outcome:  #(struct:const-exp 7)
correct

test: let-1
let x = 5 y = 6 in +(x,y)
correct outcome: 11
actual outcome:  #(struct:const-exp 11)
correct

test: let-to-proc-1
(proc (x,y) +(x,y) 5 6)
correct outcome: 11
actual outcome:  #(struct:const-exp 11)
correct

test: nested-let-1

let z = 5 x = 3
in let x = 4
       y = +(x,z)         % here x = 3
   in *(z, +(x,y))        % here x = 4
correct outcome: 60
actual outcome:  #(struct:const-exp 60)
correct

test: nested-let-as-proc

(proc (z,x)
 (proc (x,y) *(z, +(x,y)) 4 +(x,z))
 5 3)

correct outcome: 60
actual outcome:  #(struct:const-exp 60)
correct

test: nested-let-3
let z = let x = 3 in *(x,x) in z
correct outcome: 9
actual outcome:  #(struct:const-exp 9)
correct

test: bind-a-proc
let f = proc(x,y)+(x,y) in (f 3 4)
correct outcome: 7
actual outcome:  #(struct:const-exp 7)
correct

test: apply-a-proc
(proc(x,y)-(x,y)  4 3)
correct outcome: 1
actual outcome:  #(struct:const-exp 1)
correct

test: infinite-loop

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
in let loop = (fix proc (f,x) (f x))
   in (loop 1)
test skipped

test: poor-mans-letrec

let fix =  proc (f)
            let d = proc (x) proc (z) (f (x x) z)
            in proc (n) (f (d d) n)
    t4m = proc (f,x) if zero?(x) then 0 else +(4,(f -(x,1)))
in let times4 = (fix t4m)
   in (times4 3)
correct outcome: 12
actual outcome:  #(struct:const-exp 12)
correct

test: let*-1
let* x = 1 y = x x = 2 in +(x,y)
correct outcome: 3
actual outcome:  #(struct:const-exp 3)
correct

test: let*-2
let* x = 1 in let* y = 4 x = 2 in +(x,y)
correct outcome: 6
actual outcome:  #(struct:const-exp 6)
correct

test: let*-3
let* x = 1 in x
correct outcome: 1
actual outcome:  #(struct:const-exp 1)
correct

test: let*-4
let* x = proc (x,y) +(x,y) y = (x 3 4) in y
correct outcome: 7
actual outcome:  #(struct:const-exp 7)
correct

test: cond1
cond true => 2 false => 1 end
correct outcome: 2
actual outcome:  #(struct:const-exp 2)
correct

test: cond2
cond false => 2 true => 1 end
correct outcome: 1
actual outcome:  #(struct:const-exp 1)
correct

test: cond3
let* x = 0 in cond zero? (+(x,1)) => 2 zero?(x) => 1 end
correct outcome: 1
actual outcome:  #(struct:const-exp 1)
correct

test: cond4
let* x = 0 in cond zero? (+(x,1)) => 2 zero?(1) => 1 end
correct outcome: 0
actual outcome:  #(struct:const-exp 0)
correct

test: cons1
car cons 3 cons 4 cons 5 nil 
correct outcome: 3
actual outcome:  #(struct:const-exp 3)
correct

test: cons2
car cdr cons 3 cons 4 cons 5 nil 
correct outcome: 4
actual outcome:  #(struct:const-exp 4)
correct

test: cons3
nil? cons 2 nil 
correct outcome: #f
actual outcome:  #(struct:false-exp)
correct

no bugs found
> 