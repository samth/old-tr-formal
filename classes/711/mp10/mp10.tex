\documentclass[12pt]
{article}

\usepackage{amssymb}
\usepackage{alltt}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}[theorem]{Problem}



\newenvironment{proof}[1][Proof]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newenvironment{solution}[1][Solution]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}]}{\end{trivlist}}

\newcommand{\qed}{\nobreak \ifvmode \relax \else
      \ifdim\lastskip<1.5em \hskip-\lastskip
      \hskip1.5em plus0em minus0.5em \fi \nobreak
      \vrule height0.75em width0.5em depth0.25em\fi}

\title{CSG711: Problem Set 10}
\author{Sam Tobin-Hochstadt}
\date{\today}


\begin{document}

\maketitle

\begin{problem}
The program is
\begin{verbatim}
x = x0; 
y = y0; 
acc = 0;
while (x != 0) 
{
  acc = acc+y; 
  x = x-1
}
\end{verbatim}
\end{problem}

\begin{solution}
The correct invariant is $x*y + acc = x_0*y_0$.  It is obvious that
this is true at the beginning of the while loop.  After each
execution, we subtract one from $x$, and add $y$ to $acc$.  Since
$(x-1)*y+y+acc = x*y + acc$ for all values of $x$,$y$ and $acc$, this
invariant is preserved by the while loop.  Finally, when $x=0$, then
$x*y + acc = acc$, and therefore $x=0 \Rightarrow acc = x_0*y_0$.
\end {solution}

\begin{problem}
Write a program to find integer square-root by binary search. Your
program should satisfy the same specification as the integer
square-root program in the notes, but it should run in time O(log
n). Write an invariant or invariants that describe the behavior of the
program.
\end {problem}

\begin{solution}
  The program is:
  \begin{verbatim}
z := 0
u := 0
v := 0
w := 1 ;
d := 2 ;
dd := x ;
while (dd > 0){
    w := w+w+w+w
    d := d+d
    dd := dd/2
} ;

while d > 0{
    if ((u + v + w) == x)
    then {
        z := z+d/2 ;
        d := 0
    }
    else if (u + v + w > x) 
    then {
        d := d/2 ;
        u := u ;
        v := v/2 ;
        w := w/4
    }
    else {
        z := z+d/2 ;
        d := d/2 ;
        u := u + v + w ;
        v := v/2 + w ;
        w := w/4
    }
}
  \end{verbatim}

The invariant is $\sqrt{x_0} \leq upper^2 ~\wedge~ \sqrt{x_0} \geq
lower^2 ~\land~ u = z^2 ~\land~ v = zd ~\land~ w = {d^2}/{4}$.  It is
obvious that if $upper = lower$, then $upper^2 = lower^2 = x_0$.
Further, from the invariant, it is clear that $u + v + w =
(z+d/2)^2$.  

Now we must show that we initialize the variables $u,v,w$ correctly,
and maintain the invariant throughout the program. Since we start with
$z = 0$, it is clear that $u = 0$  and $v = 0$ are correct.  All that
remains is $w$, which equals $d^2/4$.  In doing this, we must ensure
that $d > \sqrt{x}$ to start with.  We do this by setting $d =
2^{\log_2 d}$ and $w=(4^{\log_2 d - 1})$ which ensures that $d \geq x$
and $w = d^2/4$ at the beginning of the program.

It is easy to show that each of the three cases of the while loop
preserves the invariant.  If $x = u+v+w$, then $z+d/2 = \sqrt{x}$, and
we are done.  Since $z' = z+d/2$ and $d' = 0$, $u$, $v$ and $w$ do not
change.    In the second case, we halve $d$, and thus do not change
$u$, halve $v$ (which is $zd$) and divide $w$ (which is $d^2/4$) by
4.  In the final case, $u' = z'^2 = (z+d/2)^2 = u + v + w$.  Also, $w$
is again quartered, and $v' = k'd' = (z+d/2)*d/2 = zd/2 + d^2/4 = v +
w/4$.  So the invariants are all preserved.

Finally, the above code was tested as a Python program (attached), and
actually works.
\end{solution}

\begin{problem}
The binary-search program in this week's lecture notes in fact works
fine even if the array A has multiple occurrences of x. Modify the
invariant so that it is preserved in this case.

The original invariant is

\[
(1 < lo) \land (hi \leq N) \land 
(\forall j)((0 < j < lo \Rightarrow A[j] < x)
\land (hi < j \leq N \Rightarrow  A[j] > x))
\]

\end {problem}

\begin{solution}
Merely modifying the original invariant to use $\leq$ instead of $<$
would not work, since then if $lo = x$ and $hi = x$, one of the sides
of the conjunction would be false.  

Instead, we need to weaken the invariant slightly, by disjoining the
body of the $\forall$ with $A[lo] = x \lor A[hi] = x$, giving us the
final invariant


$(1 < lo) \land (hi \leq N) \land (\forall j)((0 < j < lo \Rightarrow A[j] < x)
\land (hi < j \leq N \Rightarrow  A[j] > x)
\lor((A[lo] = x) \lor (A[hi] = x)))$

This is correct for the cases where there are multiple x's in array
$A$, since if there are, then the only interesting case is when one of
the $lo$ or $hi$ references points to one of the x's.  The added case
deals with this situation.


\end{solution}

\end{document}
