ParseGen grammar for quirk21.  [Revision 1]
This grammar is designed for action routines that take arguments.

Revision history:

Revision 1, 4 October 2004:
    Corrected productions for argtype.

*terminals

eof
id
charliteral
floatliteral
intliteral
stringliteral
.
(
)
[
]
*
+
,
-
/
:
;
=
==
!
sharp
ne
lt
le
gt
ge
arrow
assign
allof
and
begin
boolean
case
char
do
else
end
export
false
float
for
from
functions
if
in
int
lambda
let
letrec
new
of
oneof
or
then
to
true
types
variables
void
where
while
{
}

*productions

<program>        ::=  <exp> where <mods> eof                   #mkProgram

<mod>            ::=  export <ids> from <decs> <mod2>          #mkMod
<mod2>           ::=                                           #emptyList
                 ::=  where <exps>                             #identity

<dec>            ::=  types <typedecs>                         #mkTypeDecs
                 ::=  variables <vardecs>                      #mkVarDecs
                 ::=  functions <fundecs>                      #mkFunDecs

<vardec>         ::=  <id> = <exp>                             #mkVarDec
<fundec>         ::=  <id> = <function>                        #mkVarDec
<typedec>        ::=  <id> = <newtype>                         #mkTypeDec

<type>           ::=  <argtype>                                #identity
                 ::=  <newtype>                                #identity

<argtype>        ::=  <typename> <argtype2>                    #mk_argtype
                 ::=  <functiontype> <argtype2>                #mk_argtype

<argtype2>       ::=                                           #mk_complete
                 ::=  [ ] <argtype2>                           #mk_arraytype

<typename>       ::=  <id>                                     #mkTypeId
                 ::=  <primtype>                               #identity

<primtype>       ::=  boolean                                  #mkBooleanType
                 ::=  char                                     #mkCharType
                 ::=  int                                      #mkIntType
                 ::=  float                                    #mkFloatType

<arraytype>      ::=  <typename> [ ]                           #mkArrayType

<functiontype>   ::=  ( <argtypes> arrow <rtype> )             #mkFunctionType

<rtype>          ::=  void                                     #mkVoidType
                 ::=  <argtype>                                #identity

<newtype>        ::=  oneof { <fielddecs> }                    #mkSumType
                 ::=  allof { <fielddecs> }                    #mkProductType

<fielddec>       ::=  <id> : <argtype>                         #mkFieldDec

<function>       ::=  lambda ( <formals> ) : <rtype> . <exp>   #mkLambdaExp

<formal>         ::=  <id> : <type>                            #mkFormal

<field>          ::=  <id> : <exp>                             #mkField

<exp>            ::=  <lhs> <exp-rest>                         #mk_right
                 ::=  <function>                               #identity
                 ::=  let <vardecs> in <exp>                   #mkLetExp
                 ::=  letrec <fundecs> in <exp>                #mkLetrecExp
                 ::=  new <new-rest>                           #identity
                 ::=  case <exp> of <cases> else <exp>         #mkCaseExp
                 ::=  if <exp> then <exp> else <exp>           #mkIfExp
                 ::=  while <exp> do <exp>                     #mkWhileExp
                 ::=  for <vardec> to <exp> do <exp>           #mkForExp
                 ::=  begin <exps> end                         #mkCompoundExp
<new-rest>       ::=  <primtype> [ <exp> ] <exp>               #mk_newarray1
                 ::=  <id> <new-rest2>                         #mk_newexp
                 ::=  <functiontype> [ <exp> ] <exp>           #mk_newarray1
<new-rest2>      ::=  [ <exp> ] <exp>                          #mk_new_array
                 ::=  { <fields> }                             #mk_new_struct
<exp-rest>       ::=                                           #mk_complete
                 ::=  <assignop> <exp>                         #mk_partial
<case>           ::=  <id> : <id> then <exp>                   #mkCase

<lhs>            ::=  <disjunct> <lhs-rest>                    #mk_right
<lhs-rest>       ::=                                           #mk_complete
                 ::=  <orop> <lhs>                             #mk_partial
<disjunct>       ::=  <conjunct> <disjunct-rest>               #mk_right
<disjunct-rest>  ::=                                           #mk_complete
                 ::=  <andop> <disjunct>                       #mk_partial
<conjunct>       ::=  <simple> <conjunct-rest>                 #mk_noassoc
<conjunct-rest>  ::=                                           #mk_complete
                 ::=  <relop> <simple>                         #mk_partial
<simple>         ::=  <term> <simple-rest>                     #mk_left
<simple-rest>    ::=                                           #mk_complete
                 ::=  <addop> <term> #mk_partial <simple-rest> #mk_partial
<term>           ::=  <factor> <term-rest>                     #mk_left
<term-rest>      ::=                                           #mk_complete
                 ::=  <mulop> <factor> #mk_partial <term-rest> #mk_partial
<factor>         ::=  <unop> <factor>                          #mk_unary
                 ::=  <literal>                                #mkLiteral
                 ::=  ( <exp> ) <factor-rest>                  #mk_factor
                 ::=  <id> <factor-rest>                       #mk_factor
<factor-rest>    ::=                                           #mk_complete
                 ::=  ( <actuals> ) <factor-rest>              #mk_call
                 ::=  . <id> <factor-rest>                     #mk_qualified
                 ::=  [ <exp> ] <factor-rest>                  #mk_aref

<literal>        ::=  true                                     #mkTrue
                 ::=  false                                    #mkFalse
                 ::=  charliteral                              #mkCharLiteral
                 ::=  stringliteral                            #mkStringLiteral
                 ::=  intliteral                               #mkIntLiteral
                 ::=  floatliteral                             #mkFloatLiteral

<mods>           ::=                                           #emptyList
                 ::=  <mod> <mods>                             #cons
<ids>            ::=  <id> <ids-rest>                          #cons
<ids-rest>       ::=                                           #emptyList
                 ::=  , <ids>                                  #identity
<decs>           ::=  <dec> <decs-rest>                        #cons
<decs-rest>      ::=                                           #emptyList
                 ::=  <decs>                                   #identity
<exps>           ::=  <exp> <exps-rest>                        #cons
<exps-rest>      ::=                                           #emptyList
                 ::=  ; <exps>                                 #identity
<actuals>        ::=                                           #emptyList
                 ::=  <exp> <actuals-rest>                     #cons
<actuals-rest>   ::=                                           #emptyList
                 ::=  , <exp> <actuals-rest>                   #cons
<vardecs>        ::=  <vardec> <vardecs-rest>                  #cons
<vardecs-rest>   ::=                                           #emptyList
                 ::=  <vardecs>                                #identity
<fundecs>        ::=  <fundec> <fundecs-rest>                  #cons
<fundecs-rest>   ::=                                           #emptyList
                 ::=  <fundecs>                                #identity
<typedecs>       ::=  <typedec> <typedecs-rest>                #cons
<typedecs-rest>  ::=                                           #emptyList
                 ::=  <typedecs>                               #identity
<argtypes>       ::=                                           #emptyList
                 ::=  <argtypes1>                              #identity
<argtypes1>      ::=  <argtype> <argtypes-rest>                #cons
<argtypes-rest>  ::=                                           #emptyList
                 ::=  * <argtype> <argtypes-rest>              #cons
<fielddecs>      ::=  <fielddec> <fielddecs-rest>              #cons
<fielddecs-rest> ::=                                           #emptyList
                 ::=  , <fielddec> <fielddecs-rest>            #cons
<formals>        ::=                                           #emptyList
                 ::=  <formals1>                               #identity
<formals1>       ::=  <formal> <formals-rest>                  #cons
<formals-rest>   ::=                                           #emptyList
                 ::=  , <formal> <formals-rest>                #cons
<fields>         ::=  <field> <fields-rest>                    #cons
<fields-rest>    ::=                                           #emptyList
                 ::=  , <field> <fields-rest>                  #cons
<cases>          ::=  <case> <cases-rest>                      #cons
<cases-rest>     ::=                                           #emptyList
                 ::=  <cases>                                  #identity

<assignop>       ::=  assign                                   #mkop_assign
<orop>           ::=  or                                       #mkop_or
<andop>          ::=  and                                      #mkop_and
<relop>          ::=  ==                                       #mkop_equal
                 ::=  ne                                       #mkop_ne
                 ::=  lt                                       #mkop_less
                 ::=  le                                       #mkop_le
                 ::=  gt                                       #mkop_greater
                 ::=  ge                                       #mkop_ge
<addop>          ::=  +                                        #mkop_plus
                 ::=  -                                        #mkop_minus
<mulop>          ::=  *                                        #mkop_times
                 ::=  /                                        #mkop_divide
<unop>           ::=  !                                        #mkop_not
                 ::=  -                                        #mkop_minus
                 ::=  sharp                                    #mkop_sharp

<id>             ::=  id                                       #mkId

*end
