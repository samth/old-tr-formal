The proposition to be checked is:

A_phi F C_1 = A_phi [ TRUE U C_1]
= ~ E_phi [ ~(TRUE U C_1)]

iG = eventually always
iF = infinitely often

The weak fairness constraint is (iG en1 => iF ex1) & (iG en2 => iF ex2)

In canonical form, this is 
((iF ~en1 | iF ex1) & (iF en2 | iF ex2)) | iG false = 
(iF (~en1 | ex1) | iG false) & (iF (~en2 | ex2) | iG false)

The strong fairness constraint is (iF en1 => iF ex1) & (iF en2 => iF ex2)

In canonical form this is:
(~iF en1 | iF ex2) & (~iF en2 | iF ex2) =
(iG ~en1 | if ex2) & (~iG en2 | iF ex2)

The structure M = (S,R,L)
where S = {s1, s2, t, u}
R = {(s1,t),(s1,u),(t,s1),(u,s2),(s2,t),(s2,u)}
L = {T1, T2, C1, C2, en1, en2, ex1, ex2}


Weak Fairness
-------------------------

To model check this structure, with the given proposition, we 
follow the algoithm AFMCP(M, (p0, phi0))

First, we let S' = AFSP(M, phi0)

Caculation of S'
	We see that there is one SCC in M.  This contains all the states.  
	Since for this SCC, C,s1 satisfies ex1|~en1 and C,s2 satisfies ex2|~en2, we
	  set p_occurs[1] = true and p_occurs[2] = true.
	We are then done, and return true from AFC.  
	Since the SCC was the whole of M, the closure of S' is S'. 
	So AFSP (M, phi0) = S.

Then we add the label (E_phi X true) to each state.  

Then we begin with the smallest subformula of p0, which is C1.  This is an AP
so we skip.  The same holds for TRUE.  

The next smallest subformula if E_phi [ ~(TRUE U C_1)].  
	First we label states for FALSE, which is an AP, so we skip.
	Then we label the states s that do not have C1 in L(s) with ~C1.
		These are the states s1, s2, u.
	Then we label the states with FALSE & ~C1 if both are already in their 
		labels.  However, no states are labeled FALSE, so we label no states.
	
	Then we let S' = states labeled w/ ~C1.  This is s1, s2, u.
	Then M' = (S', {(s1,u), (u,s2), (s2,u)}, L|S')
	Then we apply AFSP(M', phi0) to get FS'.  
		In AFSP, we do the following:
		S' = {}
		X = the SCCs of M' ({s2, u}, {s1})
		Then we apply AFC to each set in X.  
		AFC({s2, u}, phi0) = 
			 For i = 1, C,s2 does not satisfy ~en1|ex1.
			 Then S' = {} since no states satisfy iG false.
			 Therefore, there are no SCC in C'.
			 Therefore, we return false
		So S' still = {}
		AFC({s1}, phi0) = 
			  For i=1, C,s1, satisfies ~en1|ex1.  
			  So p_occurs[1] = true.
			  We return true.  
		Therefore, S' = {s1}.
		The closure of {s1} is {s1,s2,u}.  
		Therefore, we return {s1,s2,u}.  
	FS' = {s1,s2,u}
	We label each state in FS' with E_phi G ~C1.  
	Then we label each state in FS' with E_phi[~(TRUE U C1)].
	Then we label each state not labeled with E_phi[~(TRUE U C1)] with its
	     negation.  This labels state t.

We have finished the algorithm, and have not labeled s1 with p0, therefore 
the structure does not satisfy p0 under weak fairness.  
			
Strong Fairness
-------------------------

phi0 = AND i=1,2(iF ex_i | iG ~en_i)

To model check this structure, with the given proposition, we 
follow the algoithm AFMCP(M, (p0, phi0))

First, we let S' = AFSP(M, phi0)

Caculation of S'
	We see that there is one SCC in M.  This contains all the states.  
	Since for this SCC, C,s1 satisfies ex1 and C,s2 satisfies ex2, we
	  set p_occurs[1] = true and p_occurs[2] = true.
	We are then done, and return true from AFC.  
	Since the SCC was the whole of M, the closure of S' is S'. 
	So AFSP (M, phi0) = S.

Then we add the label (E_phi X true) to each state.  

Then we begin with the smallest subformula of p0, which is C1.  This is an AP
so we skip.  The same holds for TRUE.  

The next smallest subformula if E_phi [ ~(TRUE U C_1)].  
	First we label states for FALSE, which is an AP, so we skip.
	Then we label the states s that do not have C1 in L(s) with ~C1.
		These are the states {s1, s2, u}.
	Then we label the states with FALSE & ~C1 if both are already in their 
		labels.  However, no states are labeled FALSE, so we label no states.
	
	Then we let S' = states labeled w/ ~C1.  This is s1, s2, u.
	Then M' = (S', {(s1,u), (u,s2), (s2,u)}, L|S')
	Then we apply AFSP(M', phi0) to get FS'.  
		In AFSP, we do the following:
		S' = {}
		X = the SCCs of M' ({s2, u}, {s1})
		Then we apply AFC to each set in X.  
		AFC({s2, u}, phi0) = 
			 For i = 1, C,s2 does not satisfy ex1. Nor deos C,u satisfy ex1.
			 S' = those states that satisfy ~en1 = {u}
			 phi0' = iF ex2 | iG ~en2
			 There is exactly one SCC in S.  
			 So, we apply AFC({u},phi0')
			     ex2 holds in u, so we return true.
			 AFC returned true, so we return true.
		S' = {s2, u}
		Therefore, S' = {s2,u}
		The closure of S' is S'.  
		We return {s2,u}.
	Then we let FS' = {s2,u}.
	Then we label each s in FS' with (E_phi G ~C1).
	Then we label each s in FS' with (E_phi [~(TRUE U C1)])
	Then we label state {s1,t} with ~(E_phi [~(TRUE U C1)]).
	Then we return.

We have completed the algorithm, and we have labeled s1 with p0.
So with strong fairness, we do have p0 satisfied by M.  
