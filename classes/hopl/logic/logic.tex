\documentclass[12pt]{article}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{enumerate}

\title{Origins of Logic Programming}
\author{Sam Tobin-Hochstadt}
\date{\today}



\begin{document}

\bibliographystyle{plain}


\maketitle

\subsection*{Predicate Logic as a Programming Language}
Kowalski, 1974 \cite{kow74}

In this paper, Kowalski lays the foundations for logic programming as
we know it.  The paper is still the standard reference for the ideas
behind logic programming.  The work in it was inspired by
collaboration with the authors of Prolog, Colmerauer and
Roussel. \cite{col93} He begins by laying out a syntax for logical
claims in the form of Horn clauses, and a way to compute with a set of
claims via refutation.

With the Horn clause syntax in place, he gives an operational
semantics for the language, which he describes as a ``procedural
interpretation''.  This semantics defines a top down method for
computing with a set of clauses and a goal statement, continuing until
a halt statement is reached.  For the language, the output at the end
is actually the substitution of the variables, since the final goal
statement is always the null statement.  

With this semantics in place for predicate logic as a programming
language, Kowalski considers the other important issues.
Nondeterminism plays a major role, both in the multiple possibilities
for a successful substitution, and the non-deterministic choice of
procedure invocation.  Since a goal statement can have multiple
conjuncts, more than one of them could be reduced at any point.  Both
of these kinds of nondeterminism are discussed, and several options
for sequencing procedure invocations are discussed.  This can have
substantial performance impact.  

\subsection*{Semantics of Predicate Logic as a Programming Language}
Van Emden and Kowalski, 1976 \cite{kow76}

The preceding paper on predicate logic as a programming language
contained a section on semantics, but these were far from formal,
especially by the standards of the day.  What that paper lacked, and
what this paper provides in quantity, is meaning functions.  Again,
this paper is foundational for the study of formal semantics of logic
programs.  

The first meaning function (called ``denotation'' in the paper) is
defined by what is described as an operational semantics.  However,
this is not an operational semantics in the sense that we now think of
them, it is instead a set of values for which a predicate is true, for
a certain kind of truth.  This is how all the meaning functions are
defined.  For the operational meaning function $D_1$, the meaning is
given by provability, that is $X\vdash Y$ iff $X \wedge \overline{Y}$
is refutable.  

The next semantics is a model theoretic one, which is given in terms
of Herbrand models of the set of clauses ${\mathbf A}$.  Here, a
predicate's denotation relative to ${\mathbf A}$ is given by those
terms which are true in all Herbrand models of ${\mathbf A}$.  Also, a
fixed-point semantics is given, where predicates are given denotations
by the least fixed point of the initial set of clauses ${\mathbf A}$.
Finally, the paper demonstrates all of these semantics to be
equivalent, and gives an interpretation of the operational semantics
in terms of Robinson's hyperresolution.   

\subsection*{Algorithm = Logic + Control}
Kowalski, 1979 \cite{kow79}

By 1979, when this paper was published, logic programming had become a
significant part of the programming community.  However, there was as
yet still not very much understanding of the difference between how to
program in predicate logic versus the traditional methods of
programming in procedural languages.  In this paper, a different
understanding of algorithms is proposed, one which takes into account
the differences that separate logic from procedural programming.  

The fundamental contribution of this paper is the equation $A = L +
C$, that is, that algorithms are the combination of logic and
control.  For Kowalski, logic is not specification but definition.  A
set of Horn clauses that make up a logic program is the logic of an
algorithm, as is the description of an algorithm that can be found in
a text book.  These concepts are familiar to procedural programmers.
However, control, the way in which the definitions are used to
compute, is not usually considered explicitly.  

Further, algorithms do not necessarily have a unique decomposition
into logic and control.  If less is specified in the logic, more must
be left up to the control to decide.  For example, if the logic of a
program specifies quicksort, there is not much for the control to
decide.  It merely follows the procedures laid out in the logic.
However, if the logic simply consists of the statement that sorting
relates a list and an ordered permutation of that list, then the
control has a far more significant job to do.  

Kowalski distinguishes two forms of control that are particularly
important for logic programs: bottom-up and top-down. Top down is the
form of control most familiar to programmers in non-logic languages.
It is also how the standard procedural interpretation of logic
programs computes.  However, there are cases where bottom up,
consisting of generating facts directly implied by constants and
assertions in the program, can actually compute faster and have other
desirable problems.  Kowalski analyzes a number of programs in this
context.  

\subsection*{The Birth of Prolog}
Colmerauer and Roussel, 1993 \cite{col93}

This paper, while very interesting, is very much unlike a standard
computer science paper.  Instead, it is a survey of work that has been
done, not from the perspective of the work, but from the perspective
of the researchers.  The reader is thus given an inside look at the
development of logic programming.  

The paper is divided into three stages in the history of Prolog.  It
begins with a natural language processing application developed in
Montreal, and continues through early Prolog into the final Prolog
much like that which we see 30 years later.  

The original idea of Colmerauer was to develop as system that would
accept statements in French and then provide answers to natural
language queries such as ``What does Tom eat?'', to which the computer
might respond ``mice''.  This was implemented in terms of an
application called Q-systems, which were expressed as sets of
rewriting rules, written with variables.  The system then used
unification to find appropriate substitutions for the variables.  

Having written the Q-systems, the group then focused on a system for
syntactic and semantic reasoning, which would allow them more power to
interpret and answer queries.  They settled on a predicate logic
formulation based on discussions with Robert Kowalski, who visited
Marseilles near that time and was in communication with Colmerauer and
Roussel.  

The system they devised bears a close resemblance to the final Prolog,
including backtracking unification and cut.  However, this version
featured a number of added-on language features which would be removed
later.  For the final version, these features were removed and the
system was made more powerful generally, resulting in the Prolog we
know today.  

\bibliography{logic}



\end{document}
