
\documentclass{acm-sigplan}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{1}
\renewcommand{\bottomfraction}{1}
\renewcommand{\floatpagefraction}{.4}
\setcounter{totalnumber}{4}
\setcounter{bottomnumber}{2}

\input{semantics-macros.tex}
\input{semantics-rules.tex}
\input{semantics-proofs.tex}
\input{paper-figs.tex}

\begin{document}

\title{A Core Calculus of Metaclasses}

\authorinfo{Sam Tobin-Hochstadt}{Northeastern University}{samth@ccs.neu.edu}
\authorinfo{Eric Allen}{Sun Microsystems Laboratories}{eric.allen@sun.com}

%\authorinfo{Sam Tobin-Hochstadt \quad Eric Allen \\
%\begin{tabular}{c}
%\\
%Sun Microsystems Laboratories \\
%Burlington MA 01803 \\
%{\tt \large <first>.<last>@sun.com} \\
%\end{tabular}
%}

\maketitle

\toappear{Submission for FOOL 2005}

\begin{abstract}
Metaclasses provide a useful mechanism for abstraction in
object-oriented languages.  But most languages supporting metaclasses
have imposed severe restrictions on their use. Typically, a metaclass
is allowed to have only a single instance and all metaclasses are
required to share a common superclass \cite{objvlisp}. In addition,
few languages supporting metaclasses have included a static type
system, and none have included a type system with nominal subtyping
(i.e., subtyping as defined in mainstream languages such as the
Java${^{\mbox{\tiny{TM}}}}$ Programming Language or C\#).

In order to elucidate the structure of
metaclasses and their relationship with static types, we present a
core calculus for a nominally-typed object-oriented language with
metaclasses and prove type soundness over this core. 
To our knowledge, no previous formalization of metaclasses in a 
language with nominal subtyping exists.
This calculus is
presented as an adaptation of Featherweight GJ \cite{FJ}, and is
powerful enough to capture metaclass relationships beyond what are
expressible in common object-oriented languages, including arbitrary
metaclass hierarchies and classes as values.  We also explore the
integration of object-oriented design patterns with metaclasses, and
show how our calculus integrates several such patterns cleanly.
\end{abstract}

\section{Introduction}
One of the stated benefits of object-oriented languages is their
ability to model aspects of the world in the object hierarchy.
However, most such languages are unable to model many simple and
common relationships. For example, consider the relationship between
physical quantities, units of measurement, and physical dimensions. It
is obvious that ``length'' is a dimension, and that ``3 feet'' is a
length.  However, modeling this relationship in a conventional
language such as the Java Programming Language is difficult without
attributing to some of these concepts properties which do not properly
belong to them.  It is natural to model {\txt 3 feet} as an instance
of a class {\txt Length}. But if we were to define a class {\txt
Dimension} and define {\txt Length} to be an instance of class {\txt
Dimension}, then {\txt Length} could not be a class and so {\txt 3
feet} could not be an instance of {\txt Length}. Alternatively, we
might define {\txt Length} to be a subclass of {\txt Dimension}. But
then we still cannot define {\txt 3 feet} to be an instance of {\txt
Length} because anything that is an instance of {\txt Length} would
also be an instance of class {\txt Dimension} and {\txt 3 feet} is
obviously not a dimension. The key limitation preventing us from
modeling this domain properly is that we cannot define a single
concept to serve both as a class and as an instance of a class.

Another example is provided by Welty and Ferrucci in \cite{FW96}, where
they show the difficulties in modeling a simple
ontology including the notions {\txt Species} and {\txt Eagle}, while
also capturing the relationship between {\txt Eagle} and {\txt Harry},
a particular eagle.  One solution they consider and reject is to
separate the notion of ``eagle'' into two concepts: {\txt the Eagle}
and {\txt Eagle}, with the former an instance of {\txt Species} and
the latter a class whose instances are specific birds.  This approach
is inadequate because it fails to express a relationship between the
notions {\txt the Eagle} and {\txt Eagle}.
Again, the limitation is that we cannot define a class as an instance of another class.
%Welty and Ferrucci proceed to explain how this limitation prevents conventional modeling
%languages from capturing many important aspects of the world.  
%The languages Ferrucci and Welty discuss cannot accommodate multiple
%universes of discourse, in which a single thing may have different meanings in different universes.

In order to overcome this limitation in expressiveness, several
object-oriented languages that are not statically typed, such as
Smalltalk, Python, and Self, allow for more flexible object
relationships \cite{Smalltalk80}, \cite{ArtMOP}, \cite{PythonMeta}. In
the case of Smalltalk and Python, classes are instances of
metaclasses. Static members of a class are modeled as ordinary members
of the corresponding metaclass.  But in both of these languages there
are important limitations on expressiveness.  For example, in
Smalltalk, the metaclass hierarchy is only two levels deep.  If we
want to represent the relationships ``{\txt A} is an instance of {\txt
B}", ``{\txt B} is an instance of {\txt C}", and ``{\txt C} is an
instance of {\txt D}", we can only do this in Smalltalk if {\txt D} is
the special Smalltalk class {\txt Metaclass}.  This does not allow the
multi-level hierarchies required to model the examples discussed above
\cite{Smalltalk80}.  Self, on the other hand, is a prototype-based
object-oriented language, where there are no classes at all; object
instantiation consists of cloning an existing instance. The members of
the clone can be modified and added to at will, dispensing with class
relationships entirely and making static checking difficult.

A more expressive metaclass system in ObjVlisp, described informally
by Conte in \cite{objvlisp}.  In ObjVlisp, there is no restriction on
the number of instances of a metaclass, and metaclasses are not
required to share a common superclass. The instance methods of a
metaclass are inherited as the static members of its instances.  Conte
makes a number of arguments for the benefits of generalized
metaclasses.  In response to complaints that the Smalltalk80 metaclass
system is too complex, he suggests that a more powerful and flexible
system has the potential to be much simpler.
%, arguing that ``The ObjVlisp model's primary advantage is uniformity.''
However, ObjVlisp does not include a static type system. 
%Cointe quotes from \cite{cardelli:multiple}: ``With respect to
%Simula, Smalltalk also abandons ... strong typing, allowing it to
%... introduce the notion of meta-classes''.   
In this paper, we show that this limitation is not necessary. We
present a semantics for a statically typed calculus of metaclasses
where, as in ObjVlisp, every class can serve as both an instance of a
class and as a class of instances, and there is no limitation on the
levels of nesting of metaclasses. In the process, we also reveal
several interesting properties about the structure that a nominal type
system for metaclasses must take. We then present a formal operational
semantics for this calculus, as well as a proof of type soundness.

Our work is motivated by \cite{DimUnits}, which presents a system for
integrating the static checking of dimensions of physical quantities
in MetaGen, an extension of the Java Programming Language with support
for metaclasses. In MetaGen, metaclasses are used to model the type
relationships of dimensions.  As with ObjVlisp, the notion of a
metaclass in MetaGen is more general than that of languages such as
Smalltalk, but, unlike ObjVlisp, MetaGen includes a static type system
\cite{DimUnits}. The calculus in this paper can be viewed as a
formalization of a purely functional core of MetaGen.

In the interests of economy and clarity of presentation, in the
following discussion we restrict ourselves to simple examples, and do
not delve into the complexities of object-oriented analysis with metaclasses.  
This is certainly not because we believe that
metaclasses are most useful for the development of toy object-oriented
programs.  On the contrary, metaclasses are most likely to show their value
in large systems, both in terms of modeling and in the treatment of
design patterns in section \ref{designpatterns}.

The remainder of this paper is organized as follows.  In section
\ref{MCJ} we present a core calculus for metaclasses we dub MCJ.
We introduce the language and describe its key features, as
well as some of the important design choices.  The motivating examples
from the introduction are presented in MCJ in section \ref{examples},
demonstrating the benefits of metaclasses. We discuss in section
\ref{designpatterns} how the need for many object-oriented ``design
patterns'' is obviated through the use of metaclasses. We then
describe the formal properties of MCJ in section \ref{formal}.  In section
\ref{formalsem} we provide a formal semantics for the language, and in
section \ref{proof} we prove a type soundness result.  In section
\ref{related} we consider related work and in section \ref{future} we
describe conclusions and future directions.

%Another, somewhat more flexible solution to this problem can be found in
%functional languages, where sets can be represented as predicates over
%objects, and sets of sets can be represented as predicates over
%predicates.  This hierarchy can obviously be extended indefinitely,
%but such programs would quickly become unwieldy.  Specialized language
%constructs would be needed for this approach to become a serious programming
%style, just as most object-oriented programming languages
%provide constructs to support that methodology.  Also in the
%functional world, higher-order functions represent a way of
%parameterizing at multiple levels, allowing some of the desired
%behavior described here to be implemented.  But few functional
%programs nest higher-orderness more than a few levels, since
%understanding the relationships  becomes more than one programmer
%could follow.  Instead, we need a way of structuring such
%relationships explicitly.

%Formal modeling of existing languages has become common, with numerous
%formal models for languages such as the Java (TM) Programming Language.  However, formal modeling
%can also serve to aid in the design process for a new language.  In
%this paper, we describe MCJ, a nominally-typed core calculus for metaclasses,
%which is intended to be the basis for a language design. While we have focused on a formal model as a language design guide, MCJ can also help understand existing languages with metaclasses.

\section{MCJ}
\label{MCJ}

\subsection{Overview}

\label{MCJintro}

MCJ is a generically-typed object-oriented calculus based on
Featherweight GJ that includes metaclasses. An MCJ program consists of
a sequence of class definitions followed by a trailing
expression. This trailing expression is evaluated in the context of
the class table induced by the class definitions.  Before discussing
the formal specification of MCJ, we first give a high-level overview
of the nature of MCJ class definitions.

Each class is an instance of a \emph{metaclass}.  A metaclass is
either a user-defined class or class {\txt Object}.  We say that if a
class {\txt C} is an instance of a class {\txt D}, then {\txt C} is an
\emph{instance class} of {\txt D}, and that {\txt D} is the
\emph{immediate containing class}, or \emph{kind}, of {\txt C}.  If
class {\txt E} is a superclass of {\txt D} then we also say that {\txt
C} is an instance class of {\txt E} and that {\txt E} is a containing
class of {\txt C}.

There are two key distinguishing features of MCJ. First, a class (or
an instantiation of a generic class) can be used as an expression.
Second, all classes have both a superclass and a kind. Instances of a
class inherit behavior from the superclass. The class itself, when
used in an expression context, inherits behavior from its kind.

A class definition consists of a header plus a collection of fields
and methods associated with the class.  The header names the class and
specifies the type parameters, as well as the superclass and the kind.
For example, the following header declares a class {\txt C} with
superclass {\txt Object} and kind {\txt D} and no type parameters:

\begin{verbatim}
class C kind D extends Object {...}
\end{verbatim}

Each class may have both class members and instance members. Class
members define the behavior of the class when used as an
instance. Instance members define the behavior of instances of a
class.  In the abstract syntax presented in this paper, class members
are distinguished from instance members by order, and with the keyword
{\txt class} \footnote{This syntax is not ambiguous because MCJ has no
inner classes.}.  Members of a class definition are laid out as
follows: first, class fields are defined, followed by class methods,
then instance fields and finally instance methods.  For example, the
following class definition includes a class method {\txt m} and an
instance method {\txt n}:

\begin{verbatim}
class C kind Object extends Object {
   class Object m() {...}
   Object n() {...}
}
\end{verbatim}

Class fields and methods bear a resemblance to static fields and
methods, but there are important differences. For a given class {\txt
C}, instance members of {\txt C}'s kind are inherited as class
members of {\txt C}. For example, a class method {\txt m} in {\txt C}
with the same name as an instance method of {\txt C}'s kind
overrides the definition of {\txt m} in the kind (and it must have the
same signature as the overridden method). Note that if an instance
class {\txt C} of type {\txt T} is assigned to a variable {\txt v} of
type {\txt T}, references to the instance members of {\txt v} refer to
the class members of {\txt C}.  As in \cite{DimUnits}, a class is
allowed to define both a static method and an instance method of the
same name. We prevent ambiguity in member references by requiring that
all references to class members in MCJ must explicitly denote the
receiver.

Superclasses behave as in \FGJ, providing implementation inheritance
of instance behavior and subtyping. A class, when used as an
expression, is an instance of its kind.  If a method is invoked on a
class {\txt C}, first the class methods of {\txt C} are examined.  If
the method is found there, it is invoked. Otherwise, the
\emph{instance} methods of the kind {\txt D} of {\txt C} are searched,
and if it is found there, the method is invoked.  Otherwise, the
superclass hierarchy of {\txt D} is examined as it is for an ordinary
instance of {\txt D}.

For example, consider the following class definitions:

\begin{verbatim}
class A kind Object extends Object {...}
class B kind Object extends A {...}
class C kind B extends Object {...}
\end{verbatim}

To resolve the method call $\invoke \C {\mof {}}$ first the class
methods of $\C$ are examined, and if a match is found, it is invoked.
Then the \emph{instance} methods of $\B$ and then $\A$ are examined.

If the method call were instead $\invoke \bb {\mof {}}$, where {\txt
b} denotes an ordinary (non-class) instance of {\txt B}, then the
instance methods of first $\B$ then $\A$ would be examined.

%For example, suppose we have the following class definitions:

%\begin{verbatim}
%class E kind Object extends Object {...}
%class D kind Object extends E {...}
%class C kind D extends Object {...}
%\end{verbatim}

%Then, for the expression:

%\begin{verbatim}
%C.m()
%\end{verbatim}

%Class {\txt C} would first be examined to see if it contained a class method named {\txt m}. If so, this method would be invoked. Otherwise, class {\txt D} would be checked to see if it contained an instance method named {\txt m}. If not, class {\txt E} would then be checked for an instance method named {\txt m}.

The generic type system of MCJ is similar to the generic type system
in \FGJ. However, as in \cite{NextGen, DimUnits}, we allow for type
variables to occur in type-dependent contexts such as casts,
preventing the use of type erasure as an implementation technique. In
addition, the receiver of a reference to a class member may be a type
variable. Unlike the system presented in \cite{MixGen}, MCJ does not
support first-class genericity because a naked type variable must not
appear in the {\txt extends} clause or {\txt kind} clause of a class
definition and {\txt new} expressions on naked type variables are not
supported. Also, polymorphic methods (which are orthogonal to the
features we explore) are not supported.

Because classes can be used as expressions, we need a bound on the
behavior of classes when used in expression contexts.  Therefore, we
place two bounds on every type variable {\txt T} in the header of the
class definition. The first bound on {\txt T} is a bound on the kind
of an instantiation of {\txt T}; the second bound is a bound on the
superclass of {\txt T}. For example, the following class header
declares a class {\txt C} with one type parameter {\txt T} that must
be instantiated with a type of kind {\txt D} that is a subtype of
{\txt E}:

\begin{verbatim}
class C<T extends (D,E)>
   kind Object
   extends Object {...}
\end{verbatim}


\subsection{Key Design Points}

\paragraph{Private Constructors}
\label{privconst}

One benefit of a metaclass system is that constructors no longer need
to play such a central role in the language. Class instances exist at
the beginning of a program execution; they need not be
constructed. Non-class instances are naturally constructed with class
(factory) methods \cite{GOF}; in this way a class instance can be
passed as a type parameter and factory methods can be called on the
class instance to construct new instances without stipulating the
class of the constructed instance. This flexibility is similar to that
provided with first-class genericity \cite{NextGen, MixGen}, but
obviates the need for {\txt with} clauses because the bound on the
kind of a type variable stipulates what factory methods can be called
on it.  A class can define class methods with arbitrary signatures
that return new instances of the class, but each such method must
ultimately include a {\txt new} expression, which can occur only
within the scope of the class whose instance it returns. A {\txt new}
expression looks like a call to method named {\txt new}, that takes a
single argument for each type parameter and each instance field of the
syntactically enclosing class. The result of a {\txt new} expression
is a new instance of the enclosing class whose type parameters are
instantiated with, and whose fields are initialized with, the given
arguments. In our formal semantics, {\txt new} expressions are
annotated with the name of the enclosing class. These annotations need
not be added by a programmer; they could be added easily by a
straightforward syntactic preprocessing over the program, since they
can be determined merely by the lexical scopes of the {\txt new}
expressions.

All uses of constructors in \FGJ\ \cite{FJ} are macro-expressible
\cite{FellExpress} in MCJ, that is, they can be expressed via local
transformations.  Of course, not all \FGJ\ programs can be expressed
in MCJ, because of the differences in the type system. Namely, MCJ
does not include polymorphic methods.

Metaclasses allow other kinds of flexibility in object creation, as
discussed in section \ref{designpatterns}.

\paragraph{Fields and Initialization}

To ensure type safety, we must have an initial value for every field,
or prevent fields from being used before they are initialized.  For
instance fields of objects created with a constructor, this is achieved
by requiring that the constructor have an argument for every instance
field.  Combined with the solution for flexibility in object creation
outlined above, this allows us the simplicity in semantics of FGJ, and
the flexibility of more general constructors.  

However, classes which are themselves instances of other classes have
fields as well, and these fields must also be initialized before they
are used.  These fields include those instance fields of the kind
which become class fields of the new class.  Our solution is to
require that \emph{all class fields, including those obtained by
inheritance, must be redeclared} and provided with values.  


% In a {\txt new} expression, all instance fields must be initialized at
% creation time. This requirement eliminates the problem of
% uninitialized instance fields. However, when a class is the kind of
% another class, the instance fields of the kind become class fields of
% the instance class.  Since the instance class can then be used as a
% value with no further initialization, these variables must be
% initialized somewhere. Our solution is to require that every class
% field inherited from a container class be included in a new class
% field definition and that every class field in a class definition
% include an initializing expression.


\paragraph{typeOf}

Given that class references can be used as expressions, it is natural
to ask: what is the type of a class reference?  
%In the world of the
%$\lambda$-calculus, such types are known as kinds.  
In MCJ, however, the kind of a class does not capture all of the
properties of the class as a value.  For example, a class may add new
class fields or class methods which are not present in the kind.
Therefore, each class freely generates a new type, which is the type
of the class considered as a value.  We represent this type with the
{\txt typeOf} operator, which takes a class instantiation and produces
a type that is not also a class.  Because this type is not a class, it
cannot be the superclass or kind of another class, and it cannot serve
as the instantiation of a generic type parameter.

These new types can create complex relationships between classes and types.  For
example, the following class headers:

\begin{verbatim}
class A() kind Object extends Object {...}
class B() kind A extends Object {...}
\end{verbatim}

induce the following type relationships:
\begin{displaymath}
\begin{array}{c}
\typ \B {\typeof \B} \\
\subtype {\typeof \B} \A \\
\B~ {\txt instanceof}\ \A
\end{array}
\end{displaymath}

\hspace{-.43cm}where we use the convention that {\txt A:B} denotes
that {\txt A} has type {\txt B}, and {\txt A<:B} denotes that {\txt A}
is a subtype of {\txt B}.

The name {\txt typeOf} has been used in other contexts to refer to a
runtime operation that determines the dynamic type of a object.
However, despite the name similarity, this function bears no
relationship to the operator described here.  In MCJ, an application
of {\txt typeOf} is a static type reference.

\paragraph{Non-transitivity}

The standard subclassing relationship, like subtyping, is transitive.
That is, if $\B$ is a subclass of $\C$ and $\C$ is a subclass of $\D$,
then $\B$ is a subclass of $\D$.  However, this relationship does not
hold for {\txt instanceof} relationships.  In general, if $\B$ is an
instance of $\C$ and $\C$ is an instance of $\D$, no judgment
about the relationship of $\B$ to $\D$ can be inferred.

Another difference between subclassing and {\txt instanceof}
relationships is that cycles can occur among instance class
relationships. The simplest such cycle is:

\begin{displaymath}
\typeFront {\typeArg \C{}} {\typeArg \C {}} \Object \braces{}
\end{displaymath}

Although this pathology appears to be dangerously close to Russell's
paradox, it does not lead to inconsistencies.  Class \C\ is an
instance of itself. It can be used in any context where one of its
instances can be used.  \C\ can be thought of as a self-replicating
value. This class hierarchy causes no problems for method lookup
because method resolution never proceeds through more than a single
containing class to an instance class. Therefore, we see no reason to
disallow it.


\subsection{Examples, Reprised}

\label{examples}

Having seen this outline of MCJ, we return to the motivational
examples discussed earlier.  First, the relationships between
dimensions is easy to capture. \footnote{Of course, dimensions have
many subtleties, not captured here.  All we present is the essence of
the type relationships.} We define 

\begin{verbatim}
class Dimension kind Object extends Object { ... }
class Length kind Dimension extends Object { ... }
class Meter kind Length extends Object { ... }
\end{verbatim}

Here {\txt Meter} is a singleton class (there is only one Meter, in
the Platonic sense).  We have easily expressed the desired type
relationships, and can statically check program invariants that rely
on dimensional relationships.

The example from \cite{FW96} is also easily expressed:

\begin{verbatim}
class Species kind Object extends Object { ... }
class Eagle kind Species extends Object {
      class Eagle make(String name) { ... }
}
Eagle harry = Eagle.make("Harry")
\end{verbatim}

Here we simply create an object to represent our concrete instance of
an Eagle.  The naive implementation of the above code in a
conventional OO language would look something like this:

\begin{verbatim}
class Species extends Object { ... }
class TheEagle extends Species { ... }
class Eagle extends Object { ... }
Eagle harry = new Eagle("Harry")
\end{verbatim}

There are at least two substantial problems with this code.  First,
{\txt TheEagle} and {\txt Eagle} have no relationship to each other in
the type system.  One is a singleton class, representing a particular
species, and one is a name for a set of objects, being the members of
that species.  The fundamental nature of species has a two-level
containment relationship, which the type system fails to express.
This means that our type checker cannot determine what we want and
cannot help us avoid mistakes.

Another problem, which is in some ways just a symptom of the first
problem but which bears special attention, is the use of generic
types.  Imagine the following method, where T is a type parameter in
scope:\footnote{Generic methods would be straightforward to add to
MCJ, but we exclude them to simplify the presentation of the type
system and to focus on the important interactions of metaclasses with
other language features.}

\begin{verbatim}
foo(T x) { ... }
\end{verbatim}

If we want to perform the call {\txt foo(harry)}, then the bound on
{\txt T} must be either {\txt Object}, in which case {\txt foo} must
have no knowledge of the object, or Eagle, in which case the function
cannot handle multiple {\txt Species}.  The ``solution'' in
conventional languages is to use a bound of {\txt Object} and insert a
downcast, which fails at runtime if the wrong argument is passed.  In
MCJ {\txt T} can be bound by kind {\txt Species}, and instantiated
with {\txt Eagle}, allowing the original call to be type-checked.
This gives the programmer both safety and expressiveness.

\section{Design Patterns as Language Features}
\label{designpatterns}

Design Patterns, as exemplified in \cite{GOF}, have had a
substantial impact on the world of object-oriented programming and
beyond.  Design patterns allow programmers to increase the flexibility
and abstraction of their software designs.  However, few design
patterns have been integrated into programming languages.

One of the advantages of our metaclass framework is that it allows
clean expression of several common design patterns in the language,
rather than requiring that they be expressed with abstraction
techniques on top of the language.  For example, a number of the
classic design patterns deal with object creation, as discussed above
in section \ref{privconst}.  It is clear that the concept of a Factory
method is easily (and necessarily) expressed in MCJ.  However, a
number of other patterns also find easy expression.  The Abstract
Factory pattern is a simple application of inheritance in the
metaclass hierarchy.  The Prototype pattern is, as mentioned in the
Design Patterns book, supported in languages with metaclasses.
Finally, there is no need for the Singleton pattern; a class itself
can serve as a singleton.  While classes can be used as limited
singletons in the Java Programming Language and in \Cpp, doing so is
undesirable because the static behavior of a class cannot inherit from
another class.  In fact, the inflexibility of class or static
operations is one of the rationales cited for the Singleton pattern.

Seeing that a number of patterns can be expressed quite simply in MCJ,
the question arises: is the simple expression of these patterns a
benefit?  We argue that it is.  The existence of design patterns is a
sign of shortcomings in language design.  Fundamentally, a design
pattern is an abstraction that cannot be expressed in the language.
For example, the Singleton and Visitor patterns are abstractions that
have obvious invariants, but they cannot be expressed directly and
they require complex cooperation from many parts of the system.

Sophisticated macro systems, such as those found in Common Lisp
\cite{steele-90} or Scheme \cite{SyntaxCase} allow for expression of
many forms of abstraction, as do extremely flexible object systems
such as CLOS. However, these solutions add significantly to what a
programmer must understand in order to use the language productively.
In contrast, the inclusion of metaclasses does not allow for arbitrary
additional abstraction, but instead makes the abstractions commonly
needed easy to express.  One does not need the full power of macros to
encode the Factory pattern.  In MCJ, we have presented a language
where several kinds of patterns are easy to express, without adding an
additional language on top of the original.


\section{Formal Specification of MCJ}

\label{formal}

Having outlined the motivation for metaclasses, and the basics of
their use, we now turn to a formal exposition of the syntax and
semantics of MCJ, followed by an outline of the proof of soundness for
the calculus.


\subsection{Syntax}
\label{Syntax}

\figSyntax

The syntax of MCJ is given in Figure \ref{fig:syntax}. When describing
the formal semantics of MCJ, we use the following metavariables:

\metavars

As in \FJ\ and many other works, $\ox$\ stands for a possibly-empty
sequence of \x.  $\SforX$ denotes a substitution of the $\oS$ for the
$\oX$, which can be applied to either an expression or a type, and
which can substitute either type or expression variables.

A number of symbols are used to abbreviate keywords: $\superSym$
stands for {\txt extends} and $\kindSym$ stands for {\txt kind}. Also
$@$ represents concatenation of sequences of syntactic constructs.
Finally, $CT(\T)$ is a lookup in the class table for the definition of
$\T$.

A number of restrictions on MCJ programs are implicit in the formal
rules.  First, we assume that all sequences of methods and fields are
free of duplicates.  Second, there is an implicit well-formedness
constraint on programs that no class be a superclass of itself, either
directly or indirectly (however, as discussed below, cycles in the
kind hierarchy are allowed).  Third, we assume that {\txt this} is
never used as the name of a variable, method or field.  We also take
\Object\ to be a distinguished member of the hierarchy, with no
specific definition, which does not have a superclass or a kind.

For example, the simplest MCJ class is:

\vspace{.1cm}
$\typeFront {\typeArg \C {}}  {\Object} \Object \braces{}$
\vspace{.1cm}

This is a class named $\C$, with no type arguments, with kind
$\Object$ and superclass $\Object$, which has no fields or methods
whatsoever.  In examples that follow, we omit empty {\txt <>}.  Note
that both the kind and the superclass are $\Object$.  MCJ does not
have a distinguished class $\Class$.  Interestingly, we determined
that a class $\Class$ would need no consideration from the type
system.  Because both $\Class$ and $\Object$ would sit atop the
hierarchy with no contents, there is no need to include
both of them.  In a more substantial language, where $\Object$ might
have methods or fields, there might be a use for a distinguished
$\Class$ class, but it would not need any special treatment by
the type system.

A more complicated MCJ class is:\footnote{Here we use {\txt extends}
for $\superSym$ and {\txt kind} for $\kindSym$.}

\begin{verbatim}
class Pair<A extends (Object, Object),
           B extends (Object, Object)>
   kind Object extends Object
{
 class Pair<A,B> make(A a, B b){ new(A,B) (a,b) } ;
 A fst;
 B snd;
 Pair<B,B> setfst(B b){
     return new <B,B> (b, this.snd);
 };
}
\end{verbatim}

This class specifies a polymorphic pair data structure.  It also
demonstrates a number of important MCJ features.  First, we see two
different kinds of methods.  The {\txt make} method creates a new
instance of {\txt Pair}.  This method contains a {\txt new}
expression, which initializes the instance fields of the class
positionally, so that the first argument to {\txt make} becomes {\txt
 fst}, and the second becomes {\txt snd}.  Also, note that we must
mention the type parameters of the newly created instance.

Second, we have an instance method, {\txt setfst}, which creates a new
pair with the old second element, and a new first element which has
the same type as the second element.

Finally, adding the following to the above definition of {\txt Pair}
gives a full MCJ program:

\begin{verbatim}
class O kind Object extends Object
{
 class O make(){return new () ()};
}

Pair<O,O>.make(O.make(), O.make()).fst
\end{verbatim}

This program, which creates two instances of {\txt O}, then creates
a {\txt Pair} to hold them both, and finally selects one of the two to
become the value of the program, demonstrates three of the expression
forms in MCJ.  {\txt Pair<O,O>} is a type, which, by itself, can
be a value.  {\txt O.make()} is a method invocation (here with a
class, not an instance, as the receiver).  The entire expression is a
field access, of the {\txt fst} instance field.

Other kinds of expressions are seen in the body of the {\txt Pair}
class.  {\txt new<A,B> (a,b)} is a new expression, which creates an
instance of the enclosing class (here {\txt Pair}).  In the body of
{\txt make} is a reference to the variable {\txt b}, which has the
obvious value.  The final form of expression writable by the
programmer is the cast, with the usual semantics. For example, {\txt
(Object)O.make()}\ is an expression of type \Object that evaluates to
an instance of {\txt O}.

With an understanding of expressions, we can examine the rest of the
{\txt Pair} class.  There are two methods: a class method ({\txt
make}) and an instance method ({\txt setfst}).  There are also two
fields, both of which are instance fields and initialized the {\txt
new} expressions. In MCJ, a {\txt new} expression is different from
those in \FGJ; each {\txt new} expression evaluates to an instance of
the syntactically enclosing class.\footnote{In the grammar of figure
\ref{fig:syntax}, {\txt new} expressions are annotated with this
enclosing class.  In the examples, this redundant information is
elided.}  Had there been additional fields in the superclass of {\txt
Pair}, it would have been necessary to initialize them in the {\txt
new} expression as well. {\txt new} expressions are explained in
detail in section \ref{privconst}.

%\footnote{There is a strong
%resemblance between the {\txt new} expressions here and the
%constructors of \FJ.  However, in MCJ they are a part of the
%language, whereas in \FJ\ they are a restriction on a more general form.}

\subsection{Semantics}
\label{formalsem}

There are two forms that a value can take in MCJ: that of an instance
class, and that of a conventional (non-class) value. If we were to
distinguish these two forms of value, we would significantly increase
the number of rules necessary to describe our semantics because every
rule referring to a value would have to be written twice. To avoid
this complexity, we introduce a special {\em mapping construct}
(similar to a record value) to denote the results of
computations.\footnote{This simplification was suggested by Jan-Willem
Maessen in response to an earlier draft of the MCJ semantics.}  A
mapping takes field names to expressions, and is annotated with a
ground type. Mappings from a sequence of fields $\of$ to a sequence of
expressions $\oe$ with type $\GG$ are written $\mapping \of \oe \GG$.
A mapping denoting an instance class {\txt C} consists of a sequence
of class fields mapped to a sequence of expressions and is annotated
with the type {\txt typeOf(C)}. Note that the right hand sides of such
maps need not always be values, and thus computation can take place
inside of a mappings.  Mappings are not available to the programmer,
and thus can only be created by operation of the reduction rules.
Therefore, unlike \FJ, our reductions do not operate entirely in the
expressible syntax of the language.  We use the metavariable $\Phi$ to
range over mappings.  When we need to refer to the type annotation of
a mapping explicitly, the metavariable is written $\Phi_{\GG}$.

The
semantics are given in figures \ref{fig:subtype}, \ref{fig:exprty}
,\ref{fig:wf}, and \ref{fig:comp} with auxiliary functions given in
figure \ref{fig:aux}.


\subsubsection{Typing}
Rules governing the typing of MCJ programs are given in figures
\ref{fig:subtype}, \ref{fig:exprty} and \ref{fig:wf}.  The
$bound_{\Delta}$ function is defined as follows:
\begin{displaymath}
\begin{array}{c}
\boundVar \\
\boundTypeof \\
\boundClass
\end{array}
\end{displaymath}

This function maps type variables and {\txt typeOf} applied to type
variables to their bounds, and leaves others unchanged.

The metavariables $\Delta$ and $\Gamma$ range over bounds
environments, written $\oX \superSym \oS$ and type environments,
written $\typ \ox \oT$ respectively.  A bounds environment contains
two bounds for each type variable, so that if $\Delta = \X \subtypeSym
(\A,\B)$, then $\Delta(\X) = \A$ and $\Delta({\typeof \X}) = \B$.

The notation $\A \subtypeSym \B$ means $\A$ is a subtype of $\B$.
Subtyping judgments are made in the context of a bounds environment,
which relates a type to the declared bound of that type from the class
header.

Type judgments are of the form $\dgprove {\typ \e \T}$, which states
that in bounds environment $\Delta$ and type environment $\Gamma$,
expression $\e$ has type $\T$.  Type judgments are not transitive in
the way that {\txt instanceof} relationships are with respect to
subtyping: if $\dgprove {\typ \e \T}$, and $\dproves {\subtype \T
\SSS}$, it is not necessarily the case that $\dgprove {\typ \e \SSS}$.
This is important, since our proofs depend on having unique
derivations of a given typing judgment. We represent empty
environments with $\emptyset$ and we abbreviate judgments of the form
$\eeproves {\typ \e \T}$ and $\eproves {\subtype \T \SSS}$ as ${\typ
\e \T}$ and ${\subtype \T \SSS}$ respectively.

We now discuss several non-obvious aspects of our type system
resulting from the need to statically check uses of metaclasses.


\paragraph{Casts and Mappings}
We follow \cite{MixGen} in typing all casts as statically correct, so as to
avoid the complications of ``stupid casts''.  Mappings, which are not
expressible in the source language, are typed merely by a
well-formedness constraint.

\subsubsection{Well-Formedness}

There are three kinds of well-formedness constraints on MCJ
programs.  First, type well-formedness, written ``$\dproves \T \ok$'',
states that type $\T$ refers to a defined class, and that if it is a type
application, the arguments satisfy the bounds.

More important are the class and method well-formedness constraints,
which together determine if a class table is well-formed, and thus
part of a legal MCJ program.  Method well-formedness is a
judgment of the form ``$\M \okin\ \GG$'', where $\M$ is a method.  We make
use of the latter portion ($\GG$) of this judgment as a second argument,
allowing us to use this rule to check both instance and class methods.
Method well-formedness consists mostly in fitting the body to the
return type, and checking for invalid overrides.

Class well-formedness involves all of the above checks.
All methods must be well-formed, and all class fields must
have correct initialization expressions.  Further, class fields
must contain the instance fields of the kind.  Finally, all
{\txt new} expressions must have the correct class name annotation.


\figExprty

\figWF

\subsubsection{Evaluation}

The evaluation rules for MCJ are given in figure \ref{fig:comp}.
The evaluation relation, written $\trans \e \ep$, states that $\e$
transitions to $\ep$ in one step.  The reflexive transitive closure of
this relation is written $\e \transarrow \ep$.

%\paragraph{Method Dispatch}
%
%Users of most object-oriented languages are familiar with the concept
%of dynamic dispatch, which resolves method access to the run-time type
%of the receiver, and looks up the class hierarchy for the closest
%matching method definition.

%The notion of classes as values has several repercussions on the semantics of dynamic dispatch.
%First, a receiver can be a type variable, meaning that the actual instantiation type of the receiver
%must be determined at runtime.
%Second, when a
%class in a receiver context does not have a matching method definition, the
%system must search upward, not to the superclass, but to the instance
%methods of the kind.  This is because although the receiver
%is a class, it is also an instance of the containing class.

\paragraph{Bad Casts}
There is one way that evaluation in MCJ can get stuck: the bad cast.
This problem occurs for all languages that allow static downcasts.  A
expression $\e$ is a bad cast iff $\e = \cast \SSS {\Phi_{\T}}$ where
\SSS\ is not a supertype of \T.

The evaluation relation given here is non-deterministic. For example,
no order is prescribed for evaluating the arguments to a {\txt new}
expression or method call, or for evaluating the initializers for
class fields.  There are also a number of places where either
congruence or reduction rules can be applied.  Therefore, in the
presence of non-termination or bad casts, the results may differ
depending on evaluation order.  However, confluence can be regained
simply by requiring that $\rulename{C-Mapping}$ is applied whenever
possible.  This restriction, combined with the requirement in the
premise of $\rulename{R-New}$ that the arguments be values, ensures
that every program with an error or non-termination will either cause
an error, or fail to terminate.  

\figComp



\subsection{Type Soundness}
\label{proof}

With the above definitions, we are now able to turn to a proof of type
soundness. Given the simplicity we are able to achieve in the
definitions, the proof is not significantly more complex than the
soundness proof given for Featherweight GJ\ \cite{FJ}.  However, there
are a number of significant lemmas, of which we list the most
important. The full proof is available at:

\vspace{.1cm}
\verb|http://research.sun.com/projects/plrg/|

\fieldsPreservedLemma

\fieldsPreservedProof

\methodTypingLemma

\methodTypingProof

\substitutionPreservesTyping
%\substitutionPreservesTypingProof
\myProof With the above two lemmas, this one follows by
straightforward structural induction over the derivation of $\dgprove
{\typ \e \T}$.

\vspace{.3cm}

Given the above lemmas, the following subject reduction proof is a
simple structural induction with a case analysis on the typing rule
used to derive $\eept \e \SSS$.

\preservation

\preservationProof

The proof of progress presents no additional complications, and
requires only one new lemma.

\fieldsAgreeLemma

\progress

\progressProof

From these, we can conclude the desired type safety result.

\soundness

\soundnessProofShort


\section{Related Work}
\label{related}

A number of object-oriented languages have included some form of
metaclass system. Most notable among these is Smalltalk
\cite{Smalltalk80}, but others include Common Lisp with CLOS
\cite{ArtMOP}.

All of these systems share a common architecture of the metaclass system
in which each class has its own freely generated metaclass, defined by
the class methods and fields of the class.  In contrast, MCJ
provides a hierarchy for structuring metaclass relationships, which
provides significantly more modeling and abstraction flexibility.

The metaclass system present in Python \cite{PythonMeta} is
similar to that provided here, where classes inheritance the instance methods
of their metaclasses as class methods.  However,
Python is dynamically-typed, and many of the uses to which Python
metaclasses are put are not possible in a statically typed language.
The work on static type systems for Python has not included
metaclasses \cite{Starkiller}.

Several type systems have also been proposed for languages with
metaclasses, including the Strongtalk language \cite{Strongtalk},
which turns Smalltalk into a structurally-typed language with
static checking.  However, because the Smalltalk metaclass
system is so different from the one in MCJ, many of the interesting
aspects of the type system do not carry over.  Furthermore, the
Strongtalk papers do not provide a formal semantics and analysis of
the system.  A formal analysis of inheritance in Smalltalk is provided
in \cite{cook:thesis} but this again does not consider the hierarchy
of metaclasses presented here.

Graver and Johnson \cite{graver:90} present another type system for
Smalltalk, with a formalism and sketch of a safety proof.  Again, the
metaclass type system is substantially different, reflecting the
underlying Smalltalk system.  Additionally, the paper is concerned
primarily with optimization as opposed to static checking.

Cointe \cite{objvlisp} presents a model of metaclasses
similar to that presented here, but for a dynamically typed object-oriented
language based on Lisp.  In it, he provides several
overlapping motivations to our own.  One is to regularize the
metaclass system of Smalltalk, and another is to enable additional
programming flexibility.  To this we add modeling freedom, and a
relation to static methods in more recent OO languages.  Cointe's
work, however, does not provide a formal model, so it is difficult to
determine the exact relationship between the two systems.  Additionally,
his work is in a untyped setting (Lisp and Smalltalk) and thus the
safety theorems proved here are not possible. 

When viewed as ``instance generators'', our metaclasses are similar to
prototypes in untyped languages such as Self.  Prototypes generate new
instances, which themselves can generate new instances.  Our language
is more restrictive than prototype-based languages in the sense that
all metaclasses and instance classes must be declared statically
(i.e., by writing down class definitions).  But our language is more
expressive in the sense that we include classes and subclassing
relationships.  Also, unlike typical prototype-based languages, our
language is statically typed.

Formalized calculi for object-oriented languages are abundant in the
programming languages community today, including \FJ\ \cite{FJ}, upon
which MCJ is based.  However, none of them have considered static
methods, which are the closest analogue of the metaclass functionality
in MCJ.

Finally, the motivation for this work comes from the language MetaGen,
introduced in \cite{DimUnits}.  MetaGen can be seen as an extension of
MCJ, which provides numerous other advanced type features.  Here we
restrict ourselves to metaclasses and analyze the properties of the
system formally.

\section{Conclusions and Future Work}
\label{future}
With MCJ, we have devised a core calculus for metaclasses that is more
flexible than that available in more traditional metaclass systems
such as Smalltalk and that allows clean expression of many common
design patterns.  In doing so, we have demonstrated that metaclasses
can be added to a nominally-typed, statically-checked language without
either significant complication of the semantics or difficulty in the
proof of soundness.

In addition to this contribution, we have elucidated several other
important points about the integration of metaclasses into an
object-oriented system.  The {\txt typeOf} type operator is to our
knowledge unique, and plays a key role in the soundness of the
system.  The discovery that the {\txt Class} class played no special
role, and that thus the class and metaclass hierarchies could both be
rooted at {\txt Object} is also novel.  Finally, we have shown how an
expressive framework of metaclasses has positive effects in other
areas of the language, such as mechanisms for object construction.  

A natural extension of the work in this paper is to expand MCJ to
include more of the features presented in \cite{DimUnits}, so as to
allow inclusion of the system for checking dimensions of physical
quantities. Such an extension would allow for a proof of  ``dimensional
soundness'' in the resulting system.  Further, any realistic system
will have imperative features, and while such features do not seem
likely to interact badly with metaclasses, no sound system is built on
such assumptions.  

Another interesting extension would be to expand our calculus to
include either multiple inheritance (as does Python) or some
alternative such as mixins or traits, as there may be interesting
interactions between metaclasses and these features that have yet to
be discovered.

\section*{Acknowledgments}

We would like to thank Jan-Willem Maessen for his 
feedback on the formal rules presented in this paper.  We also thank
David Chase for not believing in us unless we were right, Victor
Luchangco for many valuable discussions, and Guy Steele for his many
helpful comments.

\bibliographystyle{plain}

\bibliography{paper}

\end{document}
