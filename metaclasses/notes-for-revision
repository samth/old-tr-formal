* Problem with cyclic hierarchies:

Consider this class:

class Z kind Z {
Object x;
class Object x = Z.x
}

Now the expression "Z" fails to terminate.

Actually, this might be a problem in general, not just with cycles in
the class hierarchy.  Can we prevent this?  What should be in scope in
initializing expressions?

* State

There are, of course, problems extending our system to have state.  We
should at least mention them, instead of dismissing them as we do at
the very end of the paper.  For example :

 - We evaluate the initializer for a class field every time that class
is used as an expression.  Plays badly with side effects.  Is
caching/memoization a solution here?

* Object construction

 - We should mention that using static factory methods is the very
first reccommendation in Effective Java.

 - We need to emphasize that factory methods can include arbitrary
computation.  

 - Despite the private constructors, you can create instances without
using the factory method, by creating an instance class.  Does this
ruin the advantages of the factory method requirement?

     - Response: No, because you can't do it dynamically.  In Java,
everything has to go through the constructor, but to get around that
by overriding member variables.  Also, restrictions at module
boundaries.

* Method dispatch

A picture in the paper would be really useful here:

Given the class hierarchy

C : D ext Object
D ext B : X
B ext A : Y
A ext Object

Then C.m() dispatches as follows

        Class Methods | Instance Methods
----------------------------------------
A      |              |   4
B      |              |   3
C      |  1           |
D      |              |   2
X      |              |
Y      |              |
Object |              |   5

* Syntax -

The <T extends (X,Y)> syntax is terrible.  We should use <T extends X
kind Y>

FIXED (mostly)

* Values

- We need to emphasize that the mapping that is the reciver of a
method invocation or field reference must be a value.  I like the
following syntax:

\Phi\sub{G}\super{value}

FIXED

* field-vals:

field-vals is only used in one place in the semantics.  Therefore, it
could be changed to be fields-vals(C<S>) instead of
fields-vals(typeOf[C<S>]).  On the other hand, what would the second
expression then mean?  Could we just leave it off?

* We should mention ObjVLisp earlier in the paper, since our system is
so similar.  The other distinction with that paper is that they have a
class Class.  

FIXED

* Mitch Wand suggests looking at early work on lisp reflection.

* Additional discussion of Dimension typing might help with
motivation.  

* Should initializers for inherited class fields be seperated from
newly declared class fields?  Yes for a real language, probably not
for a core calculus.

* The sample implementation of the Eagle example in Java should be
moved to the introduction.  

* It was suggested during the talk that conflating Object and Class
leads to less static checking.  I disagree, but since our paper is
about enabling more checking, we should think about this.  

* We should change our examples to remove "extends Object" and (maybe)
"kind Object".  Otherwise, there's just too much verbosity.

* Shouldn't all the types in the reduction rules be ground?

* We shouldn't use the metavariable G (ranges over ground types) in
rule WF-Method, since the constrait is that it is not a naked type
variable (or typeOf[X] where X is a naked type var).
FIXED

