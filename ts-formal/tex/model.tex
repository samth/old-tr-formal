\documentclass{article}[12pt]

\usepackage{ifthen}
\usepackage{mmm}
\usepackage{ts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{fullpage}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{define}{Definition}
\usepackage{mathpartir}
\usepackage{rotating}

\newcommand\red{\to^*} 
\newcommand{\sembrack}[1]{[\![#1]\!]}


\ifthenelse{\equal{\multiargs}{true}}{
\margtrue
}
{
\margfalse
}

\ifthenelse{\equal{\paths}{true}}{
\pathtrue
}
{
\pathfalse
}

\ifthenelse{\equal{\dologic}{true}}{
\logictrue
}
{
\logicfalse
}


\newcommand{\ponly}[1]{\path{#1}{}}
\newcommand{\lonly}[1]{\logic{#1}{}}

\title{Typed Scheme}

\date{\today}

\begin{document}


\maketitle

\huge

\marg{With Multiple Arguments}{}

\path{With Paths}{}

\logic{With Logic}{}

\normalsize

\section{Syntax}


\[
  \begin{altgrammar}
    \d{}, \e{}, \dots &::=& \x{}  \alt \comb{\e{op}}{\movervec{\e{a}}} 
    \alt \cond{\e1}{\e2}{\e3} \ponly{\alt \cons{\e{}}{\e{}}} 
    \alt \lett{\x{}}{\e{}}{\e{}} \alt & \mbox{Expressions}\\
    & & \c{}  \alt \tt \alt \ff \alt
    \n{} \alt \abs{\x{}}{\t{}}{\e{}}
    &  \\
    \vv{} &::=& \c{}  \alt \tt \alt \ff \alt \n{} \alt \clos{\rho}{\abs{\x{}}{\t{}}{\e{}}} \ponly{\alt \cons{\vv{}}{\vv{}}}  & \mbox{Values} \\
\ifpath
    \c{} &::=& \addone \alt \zerop \alt \numberp \alt \boolp \alt
    \procp \alt \notsym  \alt & \mbox{Primitive Operations} \\
    &   & \consp \alt \car \alt \cdr  & 
    \vspace{1mm}
    \\
\else 
    \c{} &::=& \addone \alt \zerop \alt \numberp \alt \boolp \alt \procp \alt \notsym  & \mbox{Primitive Operations} 
    \vspace{1mm}
    \\
\fi
    \E{} &::=& [] \alt 
    \marg
        {\comb{\overvec{\vv{}}}{\E{}\ {\overvec{\e{}}}}} % general multi-arg contexts
        {\comb{\E{}}{\e{}} \alt \comb{\vv{}}{\E{}}} % one-arg contexts
        \ponly{\alt \cons{\E{}}{\e{}} \alt \cons{\vv{}}{\E{}}} \alt
        \cond{\E{}}{\e{}}{\e{}} 
        \alt \marg{(\letsym\ (\movervec{[\x{}\ \vv{}]}\ [{\x{}}\ {\E{}}]\ \movervec{[\x{}\ \e{}]})\ {\e{}})}{\lett{\x{}}{\E{}}{\e{}}}
        & \mbox{Evaluation Contexts} \vspace{1mm} \\
  \end{altgrammar}
  \]
\hrule
\[
  \begin{altgrammar}
    \sig{},\t{} &::= & \topty \alt \marg{\proctop \alt}{} \num \alt \ttt \alt \fft 
    \alt \consty{\t{}}{\t{}} \alt
         {\proctype {\movervec[i]{\t{}}} {\t{}} {\movervec[i]{\phih{}}} {\sh{}}} 
         \alt (\usym\ \overvec{\t{}})     &\mbox{Types} \\

         \nu &::=& \t{\ponly{\pi}} \alt \compt{\ponly{\pi}} & \mbox{Type Propositions}\\

         \p{} &::=&  \nu_{\x{}}
         \lonly{\alt \imp{\p{}}{\p{}}} \alt \p{} \vee \p{} \alt \p{}
         \wedge \p{} \alt
         \bot \alt \top & \mbox{Filters} \\

         \ph{} & ::=& \nu \alt \nu_{\x{}}
         \lonly{\alt \imp{\ph{}}{\ph{}}} \alt \ph{} \vee \ph{} \alt
         \ph{} \wedge \ph{} 
         \alt \both \alt \toph & \mbox{Latent Filters} \\


         \s{} & ::= &   \wpi{\x{}} \alt \noeffect &\mbox{Objects} \\
         
         \sh{} & ::= & \pathmaybe{\pii} \alt \noeffect  & \mbox{Projections (Latent Objects)} \\
         \ifpath
         \pi & ::= & \overvec{\pe{}} & \mbox{Paths}\\
         
         \pe{} & :: = & \pecar \alt \pecdr & \mbox{Path Elements} \\
         \else
         \fi
         
         \Gamma & ::= & \overvec{\p{}} & \mbox{Type Environments} \\
  \end{altgrammar}
  \]

\paragraph{Notation:}
We write \bool for $(\usym \ttt\ \fft)$.  We also
abbreviate $\epsilon(\x{})$ as $\x{}$.

\ifmarg
The type $\proctop$ represents the supertype of all procedures, so
$\subtype{\proctype {\movervec[i]{\t{}}}{\sig}{\movervec[i]{\phih{}}}
  {\sh{}}}{\proctop}$ for any $\movervec[i]{\t{}}$, \sig{},
${\movervec[i]{\phih{}}}$  and $\sh{}$.  Note that this type is not
otherwise representable.
\else
\fi

\section{Type Judgement}

\huge
\begin{displaymath}
  \hastyeff{\e{}}{\t{}}{\p+}{\p-}{\s{}}
\end{displaymath}
\normalsize

This means that in environment $\Gamma$, \e{} has the type \t{}, that
evaluating \e{} and recieving a true value means that \p+ is true,
that evaluating \e{} and recieving $\ff$ means that \p- is true, and
that testing \e{} is the same as testing the object \s{}.

%\newpage

\section{Type Rules}

\paragraph{Core Type Rules}

\[
\inferrule[T-Var]{\Gamma \vdash \t{\x{}}}{\hastyvar {\x{}} {\t{}} {\x{}}}
\qquad\qquad
\inferrule[T-Num]{}{\hastytrue{\n{}}{\num}} 
\qquad\qquad
\inferrule[T-Const]{}{\hastytrue{\c{}}{\dt{\c{}}}}
\]



\[
\inferrule[T-True]{}{\hastytrue{\tt}{\ttt}}
\qquad\qquad
\inferrule[T-False]{}{\hastyfalse{\ff}{\fft}}
\]


\newcommand{\msubi}[1]{\marg{{#1}_i}{#1}}

\renewcommand{\xi}{\msubi{\x{}}}
\newcommand{\sai}{\msubi{\s{a}}}


\[
\inferrule[T-Abs]
{\hastyeffphi [\G{},{\movervec[i]{\sig{\x{}}}}] {\e{}} {\t{}} {\phii{}} {\s{}} \\\\
\movervec[i]{\phih{} = \abstractfilter {\xi} {\phii{}}} \\\\
\sh{} = \abstractobject{\movervec[i]{\x{}}}{\s{}}
% \left\{
%  \protect{\begin{array}{ll}
%   \pathmaybe{\pii}     & \text{if } \s{} = \wpi{\xi} \\
%   \noeffect  & \text{otherwise}
%  \end{array}} \right.
}
{\hastytrue
  {\abs[i]{\x{}}{\sig{}}{\e{}}} 
  {\proctype {\movervec[i]{\sig{}}} {\t{}} {\movervec[i]{\phih{}}} {\sh{}}}
}
\qquad\qquad
\inferrule[T-App]
{ \hastyeffphi {\e{op}} {\t{op}}   {\phii{op}} {\s{op}}\\  
  \movervec[i]{\hastyeffphi {\e{a}} {\t{a}}  {\phii{a}} {\s{a}}}\\\\ 
  \movervec[i]{\subtype {\t{a}}{\t{f}}} \\
  {\subtype {\t{op}} {\proctype{\movervec[i]{\t{f}}}{\t{r}}{\movervec[i]{\phih{f}}}{\sh{f}}}} \\\\
\phii{r} = \movervec[i]{\applyfilter{\phih{f}}{\t{a}}{\s{a}}} \\\\
\s{r} = \applyobject{\movervec[i]{\s{a}}}{\sh{f}}
 % \left\{
 %  \protect{\begin{array}{ll}
 %      \wpip{\wpi{x}}     & \text{if } \sh{} = \pathmaybe{\pipi} \text{ and } {\sai} = \wpi{\x{}} \\
 %      \noeffect  & \text{otherwise}
 %    \end{array}} \right.
}
{\hastyeffphi {\comb{\e{op}}{\movervec[i]{\e{a}}}} {\t{r}} {\phii{r}} {\s{r}}}
\]

\[
\inferrule[T-If]
{
  \hastyeff{\e1}{\t1}{\p{1_+}}{\p{1_-}}{\s1}
  \\\\
  \hastyeff[\G{}, {\p{1_+}}]{\e2}{\t2}{\p{2_+}}{\p{2_-}} {\s2}
  \\\\
  \hastyeff[\G{}, {\p{1_-}}]{\e3}{\t3}{\p{3_+}}{\p{3_-}} {\s3}
  \\\\
  \subtype{\t2}{\t{}} \\
  \subtype{\t3}{\t{}} \\\\
  \p{+} = (\p{1_+} \wedge \p{2_+}) \vee (\p{1_-} \wedge \p{3_+}) \\\\
  \p{-} = (\p{1_+} \wedge \p{2_-}) \vee (\p{1_-} \wedge \p{3_-}) 
%  \phii{} = \combfilter{\p1|\p2}{\phii2}{\phii3}
}
{\hastyeff {\cond{\e1}{\e2}{\e3}} {\t{}}  {\p{+}} {\p{-}} {\noeffect}}
\qquad\qquad
\inferrule[T-Let]
{\movervec{\hastyeff{\e0}{\t{}}{\p{0_+}}{\p{0_-}}{\s0}}\\\\
\hastyeffphi[\G{}, \movervec{\t{\x{}}}, \movervec{\imp{\comp{\fft}_{\x{}}}{\p{0_+}}, \imp{{\fft}_{\x{}}}{\p{0_-}}}]{\e1}{\sig{}}{\phii1}{\s1}}
{\hastyeffphi{\lett{\x{}}{\e0}{\e1}}{\sig{}}{\phii1}{\s1}}
\]

\ifpath

\paragraph{Rules for Pairs}

\begin{displaymath}
  \inferrule[T-Cons]
  {
    \hastyeffphi{\e1}{\t1}{\phii1}{\s1} \\\\ \hastyeffphi{\e2}{\t2}{\phii2}{\s2} 
  }
  {
    \hastytrue{\cons{\e1}{\e2}} {\consty{\t1}{\t2}}
  }
\end{displaymath}

\begin{displaymath}
\inferrule[T-Car]
  {
    \hastyeffphi{\e{}} {\consty{\t1}{\t2}} {\phii{}} {\s{}} \\\\
    \phii{r} = \applyfilter{\comp{\fft}_{\pecar}|{\fft}_{\pecar}}{\consty{\t1}{\t2}} {\s{}} \\\\
    \s{r} = \applyobject{\pecar}{\s{}}
  }
  {
    \hastyeffphi{\comb{\car}{\e{}}}{\t1}{\phii{r}}{\s{r}}
  }
  \qquad\qquad
  \inferrule[T-Cdr]
  {
    \hastyeffphi{\e{}} {\consty{\t1}{\t2}} {\phii{}} {\s{}} \\\\
    \phii{r} = \applyfilter{\comp{\fft}_{\pecdr}|{\fft}_{\pecdr}}{\consty{\t1}{\t2}} {\s{}} \\\\
    \s{r} = \applyobject{\pecdr}{\s{}}
  }
  {
    \hastyeffphi{\comb{\cdr}{\e{}}}{\t2}{\phii{r}}{\s{r}} 
  }
\end{displaymath}

\else
\fi


\paragraph{Auxilliary Type Rules}

\begin{displaymath}
  \inferrule[T-Not]
  {
    \hastyeff{\e{}}{\t{}}{\p1}{\p2}{\s{}}      
  }
  {
    \hastyeff{\nott{\e{}}}{\bool}{\p2}{\p1}{\noeffect}      
  }
  \qquad\qquad
  \inferrule[T-Bot]
  {
    \Gamma \vdash (\usymsmall)_{\wpi{\x{}}}
  }
  {
    \hastyeffphi{\e{}}{\t{}}{\p1|\p2}{\s{}}
  }
\end{displaymath}

{\sc T-Bot} is needed to avoid complaints about spurious unreachable
code, and it takes the place of the earlier rules {\sc T-IfTrue} and
{\sc T-IfFalse}.


\section{Environment Rules}

\newcommand{\update}[3][\Gamma(\x{})]{\mathrm{update}({#1},{#3}{\ponly{,#2}})}
\newcommand{\updatesimp}[2]{\mathrm{update}({#1},{#2})}


\[
\inferrule[L-Atom]
{\p{} \in \Gamma}
{\Gamma \vdash \p{}}
\qquad \qquad
\inferrule[L-Bot]
{\Gamma \vdash \bot}
{\Gamma \vdash \t{\wpi{\x{}}}}
\qquad\qquad
\inferrule[L-AndI]{\Gamma \vdash \p1\\\\\Gamma \vdash \p2}{\Gamma
  \vdash \p1 \wedge \p2}
\qquad\qquad
\inferrule[L-AndE]{\Gamma, \p1 \vdash \p{} \text{ or } \Gamma, \p2 \vdash \p{}}{\Gamma
  , \p1 \wedge \p2 \vdash \p{}}
\]
\[
\inferrule[L-ImpI]{\Gamma,\p{} \vdash \p{}'}{\Gamma \vdash \imp{\p{}}{\p{}'}}
\qquad\qquad
\inferrule[L-ImpE]
{{\Gamma \vdash \p{}} \\\\ \Gamma \vdash \imp{\p{}}{\p{}'}}
{{\Gamma \vdash \p{}'}}
\qquad\qquad
\inferrule[L-OrI]{\Gamma \vdash \p1 \text{ or }\Gamma \vdash \p2}{\Gamma \vdash \p1 \vee \p2}
\qquad\qquad
\inferrule[L-OrE]{\Gamma, \p1 \vdash \p{} \\\\ \Gamma, \p2 \vdash \p{}}{\Gamma, \p1 \vee \p2 \vdash \p{}}
\]
\[
\inferrule[L-Sub]{\Gamma \vdash \t{\wpi{\x{}}} \\ \subtype{\t{}}{\sig{}}}{\Gamma \vdash \sig{\wpi{\x{}}}}
\qquad\qquad
\inferrule[L-SubNot]{\Gamma \vdash \comp{\sig{}}_{\wpi{\x{}}} \\ \subtype{\t{}}{\sig{}}}{\Gamma \vdash \comp{\t{}}_{\wpi{\x{}}}}
\qquad \qquad
\inferrule[L-Update]
{\Gamma \vdash \t{\wpi{\wpip{\x{}}}} \\ \Gamma \vdash \nu_{\wpip{\x{}}}}
{\Gamma \vdash {\update[\t{}]{\pi}{\nu}}_{\wpip{\x{}}}}
\]


\section{Subtyping}


\[
\inferrule[S-Refl]{ }{\subtype{\t{}}{\t{}}}
\ifmarg
\qquad\qquad
\inferrule[S-ProcTop]
{ }{\subtype {\proctype {\movervec[i]{\sig{}}} {\t{}} {\movervec[i]{\phih{}}} {\sh{}}} {\proctop}}
\else
\fi
\qquad\qquad
\inferrule[S-Top]{ }{\subtype{\t{}}{\topty}}
\]

\[
\ifpath
\inferrule[S-Pair]
{
  \subtype{\t1}{\t2} \\
  \subtype{\sig1}{\sig2}
}
{
  \subtype{\consty{\t1}{\sig1}}{\consty{\t2}{\sig2}}
}
\qquad\qquad
\else
\fi
\inferrule[S-Fun]
{
  \movervec[i]{\subtype{\sig{a}}{\t{a}}} \\ 
  \subtype{\t{r}}{\sig{r}} \\\\ 
  \sh{} = \sh{}' \text{ or } \sh{}' = \noeffect
}
{
  \subtype
  {\proctype{\movervec[i]{\t{a}}}{\t{r}}{\movervec[i]{\phih{}}}{\sh{}}}
  {\proctype{\movervec[i]{\sig{a}}}{\sig{r}}{\movervec[i]{\phih{}}}{\sh{}'}}
}
\]

\[
\inferrule[S-UnionSuper]
{\exists i.\ {\subtype{\t{}}{\sig{i}}}}
{\subtype{\t{}}{(\usym\ \overvec[i]{\sig{}})}}
\qquad\qquad
\inferrule[S-UnionSub]
{\overvec[i]{\subtype{\t{i}}{\sig{}}}}
{\subtype{(\usym\ \overvec[i]{\t{}})}{\sig{}}}
\]

\ifpath
\vspace{5mm}

There's still a problem here: 
\notsubtype 
{\consty{\uniontwo{\t{}}{\sig{}}}{\ups{}}}
{\uniontwo {\consty{\t{}} {\ups{}}} {\consty{\sig{}} {\ups{}}}  } 

This can be fixed with a subtyping algorithm presented in a paper by Voillion.
\fi
%% Unclear if we need a subeffecting relation - it was only used in the proof

% \[
% \inferrule[SE-Refl]{}{\subeff{\p{}}{\p{}}}
% \qquad\qquad
% \inferrule[SE-None]{}{\subeff{\p{}}{\noeffect}}
% \]

% \[
% \inferrule[SE-True]{\p{} \neq \ff}{\subeff{\tt}{\p{}}}
% \qquad\qquad
% \inferrule[SE-False]{\p{} \neq \tt}{\subeff{\ff}{\p{}}}
% \]


\newpage

\section{Metafunctions}

\newcommand{\af}[3]{\abstractfilter{#1}{#2} & {#3}}
\newcommand{\apf}[4]{\applyfilter{#1}{#2}{#3} & {#4}}

\subsection{Abstract}

$$
  \begin{array}{l@{\ =\ }l@{\qquad}l}
    \af{\x{}}{\p{+}|\p{-}}{{\abstractone[\x{}]{\p{+}}}|{\abstractone[\x{}]{\p{-}}}} &  \vspace{2mm}\\

    \abstractone{\nu_{\x{}}}& \nu & \\
    \abstractone{\nu_{\y{}}}& \nu_{\y{}} &  \text{ where } \x{}
    \neq \y{} \\
    \abstractone{\bot}& {\both} & \\
    \abstractone{\top}& {\toph} & \\
    \abstractone{\imp{\p1}{\p2}} & \imp{\abstractone{\p1}}{\abstractone{\p2}}& \\
    \abstractone{{\p1}\vee{\p2}} & {\abstractone{\p1}}\vee{\abstractone{\p2}}& \\
    \abstractone{{\p1}\wedge{\p2}} & {\abstractone{\p1}}\wedge{\abstractone{\p2}}& \vspace{2mm}\\
%    \text{ where }
%    \ph{} = \left\{
%      \protect{\begin{array}{ll}
%          \both             & \text{if } \bot \in \p{i} \\
%          \bullet        & \text{otherwise}
%        \end{array}} \right.
    \abstractobject{\movervec[i]{\x{}}}{\wpi{\xi}} & \pathmaybe{\pii} &
    \\
    \abstractobject{\movervec[i]{\x{}}}{\s{}} & \noeffect & \text{ otherwise}\\
   \end{array}
$$
%
\subsection{Apply}

$$
  \begin{array}{l@{\ =\ }l@{\qquad}l}
    \apf{\ph{+}|\ph{-}}{\t{}}{\s{}}{{\applyone{\ph+}{\s{}}}|{\applyone{\ph-}{\s{}}}} &
%    {\overvec[i]{\p{+_+}},\overvec[j]{\p{-_-}}|
%     \overvec[i]{\p{-_+}},\overvec[j]{\p{+_-}}} & 
%   \text{ where } \overvec[i]{\p{+_+},{\p{+_-}}}  = \overvec[i]{\applyone{\ph+}{\t{}}{\s{}}} \\
%   & & & \text{ and } \overvec[j]{\p{-_+},{\p{-_-}}}  = \overvec[j]{\applyone{\ph-}{\t{}}{\s{}}} \\
\vspace{2mm}\\



    \applyone{\both}{\s{}} & \bot & \\
    \applyone{\nu} {\wpi{\x{}}} & \nu_{\wpi{\x{}}} & \\
    \applyone{\nu_{\x{}}} {\s{}} & \nu_{\x{}} & \\
    \applyone{\imp{\ph1}{\ph2}}{\s{}} & \imp{\applyone{\ph1}{\s{}}}{\applyone{\ph2}{\s{}}}& \\
    \applyone{{\ph1}\vee{\ph2}}{\s{}} & {\applyone{\ph1}{\s{}}}\vee{\applyone{\ph2}{\s{}}}& \\
    \applyone{{\ph1}\wedge{\ph2}}{\s{}} &
    {\applyone{\ph1}{\s{}}}\wedge{\applyone{\ph2}{\s{}}}&\\

    \applyone{\ph{}}{\s{}} & \top &  \text{ otherwise}\vspace{2mm}\\


    \applyobject{\movervec[i]{\s{a}}}{\pathmaybe{\pipi}}  &      \wpip{\wpi{x}}
    & \text{ if } {\sai} = \wpi{\x{}} \\
    \applyobject{\movervec[i]{\s{a}}}{\sh{}}  &  \noeffect  & \text{ otherwise} \\

   \end{array}
$$

\subsection{Constant Typing}

\[
\begin{array}{@{}l@{\ =\ }l@{\qquad}l}
  \dt{\numberp} & {\predty{\relax}{\num}} & \\
  \dt{\procp} & {\predty{\relax}{\proctop}} & \\
  \dt{\boolp} & {\predty{\relax}{\bool}} & \\
\ifpath
  \dt{\consp} & {\predty{\relax}{\consty{\topty}{\topty}}} & \\
\fi
  \dt{\addone} & {\simpleproc{\num}{\num}} & \\
  \dt{\notsym} & {\simpleproc{\topty}{\bool}} & \\
  \dt{\zerop} & {\simpleproc{\num}{\bool}} & \\
\end{array}
\]


% \subsection{Combine}

% There are many possibilities for $\combfilter{-}{-}{-}$.  One is the
% very conservative

% $$%
% \begin{array}{l@{\ =\ }l@{\qquad}l}
% \combfilter{\phii1}{\phii2}{\phii3} & \bullet|\bullet & 
% \end{array}
% $$

% \noindent
% A more sophisticated version is:


% \newcommand{\ts}{\uniontwo{\t{}}{\s{}}}

% $$
% \begin{array}{l@{\ =\ }l@{\qquad}l}
% \combfilter{\phii{}}{\bullet|\bot}{\bot|\bullet} & \phii{}
% & \text{  the student expansion}\\

% \combfilter{\bullet|\bot}{\phii2}{\phii3} & \phii2 & \\

% \combfilter{\bot|\bullet}{\phii2}{\phii3} & \phii3 & \vspace{3mm}\\

% \multicolumn{2}{l}{\combfilter 
% {\t{\wpi{\x{}}}::\p{1_+}|\comp{\t{}}_{\wpi{\x{}}}::\p{1_-}}
% {\bullet|\bot}
% {{\sig{\wpi{\x{}}}::\p{3_+}|\comp{\sig{}}_{\wpi{\x{}}}::\p{3_-}}} 
% }
%   & \text{ or with predicates} \\
% & \ts_{\wpi{\x{}}}::\p+|{\comp{\ts}}_{\wpi{\x{}}}::\p- & \\
% \multicolumn{3}{c}{\text{where } \p+|\p- = \combfilter{\p1_+|\p1_-}{\bullet|\bot}{\p3_+|\p3_-}} \vspace{3mm}\\

% \combfilter{\p{1_+}|\p{1_-}} {\bullet|\bot} {\p{3_+}|\p{3_-}} & {\bullet|\p{1_-},\p{3_-}}& \text{ or} \vspace{3mm}\\

% \combfilter{\p{1_+}|\p{1_-}} {\p{2_+}|\p{2_-}} {\bot|\bullet} & \p{1_+},\p{2_+}|\imp{\p{1_+}}{\p{2_-}},\imp{\p{2_+}}{\p{1_-}} & \text{ and} \vspace{3mm}\\

% \combfilter{\phii{}}{\phii{}'}{\phii{}'} & \phii{}' & \\

% \combfilter{\phii1}{\phii2}{\phii3} & \bullet|\bullet & \text{ otherwise}
% \end{array}
% $$

% Rules 2 and 3 might only be needed in the proof.


\newpage

\section{Operational Semantics}

\subsection{Small Step Semantics}

\[
\inferrule*[lab={E-Delta}]
        {\del{\c{}}{\vv{}} = \vv{}'}
        {\step{\comb{\c{}}{\vv{}}}{\vv{}'}}
\qquad\qquad
\inferrule[E-Beta]{}
      {\step{\comb{\abs[i]{\x{}}{\t{}}{\e{b}}}{\movervec[i]{\vv{a}}}}{\subsmulti{\e{b}}{\x{}}{\vv{a}}{i}}}
\qquad\qquad
\inferrule[E-Let]{}{\step{\lett[i]{\x{}}{\vv{a}}{\e{b}}}{\subsmulti{\e{b}}{\x{}}{\vv{a}}{i}}}
\]

\[
\inferrule[E-IfFalse]{}
      {\step{\cond{\ff}{\e2}{\e3}}{\e3}}
\qquad\qquad
\inferrule[E-IfTrue]{\vv{} \neq \ff}
      {\step{\cond{\vv{}}{\e2}{\e3}}{\e2}}
\]

\[
\inferrule*
        {\step{L}{R}}
        {\reduce{\E{}[L]}{\E{}[R]}}
\]

\vspace{5mm}

\subsection{Big Step Semantics}

\[
\inferrule[B-Var]{\rho(\x{}) = \vv{}}{\eval{\x{}}{\vv{}}}
\qquad\qquad
\inferrule[B-Delta]{\evalprime{\e{}}{\c{}}
  \\ \evalprime{\e{}'}{\vv{}} 
  \\\\ \del{\c{}}{\vv{}} = \vv{}'}
{\evalpp{\comb{\e{}}{\e{}'}}{\vv{}'}}
\qquad\qquad
\inferrule[B-Let]
{
  {\evalprime{\movervec{\e{a}}}{\movervec{\vv{a}}}}
  \\\\ 
  \evaltwo{\rho[\movervec{\x{} \mapsto \vv{a}}]}
  {\e{b}}{\rho''}{\vv{}}
}
{\evaltwo{{\rho}}{{\lett{\x{}}{\e{a}}{\e{b}}}}{\rpp}{\vv{}}}
\qquad\qquad
\inferrule[B-Beta]
{
  \evalprime{\e{f}}{\clos{\rho_c}{\abs[i]{\x{}}{\t{}}{\e{b}}}}
  \\\\ 
  {\evalprime{\movervec[i]{\e{a}}}{\movervec[i]{\vv{a}}}}
  \\\\ 
  \evaltwo {\rho_c[\movervec{\x{} \mapsto \vv{a}}]} {\e{b}} {\rho'''} {\vv{}}
}
{\evaltwo{\rho}{\comb{\e{f}}{\movervec[i]{\e{a}}}}{\rho'''}{\vv{}}}
\]
\[
\inferrule[B-Val]{}{\eval{\vv{}}{\vv{}}}
\qquad
\inferrule[B-Abs]{}{\eval{\abs{\x{}}{\t{}}{\e{}}}{\clos{\rho}{\abs{\x{}}{\t{}}{\e{}}}}}
\ifpath
\qquad
\inferrule[B-Cons]{\evalprime{\e1}{\vv1} \\\\ \evalprime{\e2}{\vv2}}
{\evalpp{\cons{\e1}{\e2}}{\cons{\vv1}{\vv2}}}
\fi
\qquad
\inferrule[B-IfTrue]{\evalprime{\e1}{\vv1} \\\\ \vv1 \neq \ff\\\\
  \evalprime{\e2}{\vv{}}}
{\evalpp{\cond{\e1}{\e2}{\e3}}{\vv{}}}
\qquad
\inferrule[B-IfFalse]{\evalprime{\e1}{\ff} \\\\
  \evalprime{\e3}{\vv{}}}
{\evalpp{\cond{\e1}{\e2}{\e3}}{\vv{}}}
\]
\subsection{Constants}


\[
\begin{array}{@{}l@{\ =\ }l@{\qquad}l}
  \del{\addone}{\n{}} & \n{} + 1 & \vspace{2mm}\\

  \del{\notsym}{\ff} & \tt & \\
  \del{\notsym}{\vv{}} & \ff & \text{ otherwise}\vspace{2mm}\\

  \del{\zerop}{0} & \tt & \\
  \del{\zerop}{\n{}} & \ff & \text{ otherwise} \vspace{2mm}\\

  \del{\numberp}{\n{}} & \tt & \\
  \del{\numberp}{\vv{}} & \ff & \text{ otherwise}\vspace{2mm}\\

  \del{\boolp}{\tt} & \tt & \\
  \del{\boolp}{\ff} & \tt & \\
  \del{\boolp}{\vv{}} & \ff & \text{ otherwise}\vspace{2mm}\\

  \del{\procp}{\abs{\x{}}{\t{}}{\e{}}} & \tt & \\
  \del{\procp}{\c{}} & \tt & \\
  \del{\procp}{\vv{}} & \ff & \text{ otherwise}\vspace{2mm}\\
\ifpath
  \del{\consp}{\cons{\vv1}{\vv2}} & \tt & \\
  \del{\consp}{\vv{}} & \ff & \text{ otherwise}\vspace{2mm}\\

  \del{\car}{\cons{\vv1}{\vv2}} & \vv1 & \\
  \del{\cdr}{\cons{\vv1}{\vv2}} & \vv2 & \\
\fi
\end{array}
\]


\newpage
\section{Type Operations}


$$
\begin{array}{@{}l@{\ =\ }l@{\qquad}l}
\ifpath
  \update[\consty{\t{}}{\sig{}}]{\pi::\pecar}{\nu} & \consty{\update[\t{}]{\pi}{\nu}}{\sig{}}  & \\
%  \update[\consty{\t{}}{\sig{}}]{\pi::\pecar}{\comp{\ups{}}} & \consty{\update[\t{}]{\pi}{\comp{\ups{}}}}{\sig{}}  & \\

  \update[\consty{\t{}}{\sig{}}]{\pi::\pecdr}{\nu} & \consty{\t{}}{\update[\sig{}]{\pi}{\nu}}  & \\
%  \update[\consty{\t{}}{\sig{}}]{\pi::\pecdr}{\comp{\ups{}}} & \consty{\t{}}{\update[\sig{}]{\pi}{\comp{\ups{}}}}  & \\
\fi
  \update[\t{}]{\bullet}{\ups{}} & \restrict{\t{}}{\ups{}}& \\

  \update[\t{}]{\bullet}{\comp{\ups{}}} & \remove{\t{}}{\ups{}}& \vspace{5mm}\\
%  \updatesimp{\t{}}{\both} & {\bot} & \\
  \restrict{\t{}}{\sig{}} & \botty & \text{ if } {\nooverlap{\t{}}{\sig{}}} \\
  \restrict{(\usymsmall\ \overvec{\t{}})}{\sig{}} & (\usymsmall\ \overvec{\restrict{\t{}}{\sig{}}})& \\
  \restrict{\t{}}{\sig{}} & \t{} & \text{ if } {\subtype{\t{}}{\sig{}}} \\
  \restrict{\t{}}{\sig{}} & \sig{} & \text{ otherwise} \vspace{5mm}\\


  \remove{\t{}}{\sig{}} & \botty & \text{ if } {\subtype{\t{}}{\sig{}}} \\
  \remove{(\usymsmall\ \overvec{\t{}})}{\sig{}} & (\usymsmall\ \overvec{\remove{\t{}}{\sig{}}})& \\
  \remove{\t{}}{\sig{}} & \t{} & \text{ otherwise} \vspace{5mm}\\

  \nooverlap{\num}{\bool} & \mathrm{true} & \\
\ifpath
  \nooverlap{\num}{\consty{\t{}}{\sig{}}} & \mathrm{true} & \\
  \nooverlap{\bool}{\consty{\t{}}{\sig{}}} & \mathrm{true} & \\
\fi
  \nooverlap{\num}{\proctype{\movervec[i]{\t{}}}{\sig{}}{\movervec[i]{\phih{}}}{\sh{}}} & \mathrm{true} & \\
  \nooverlap{\bool}{\proctype{\movervec[i]{\t{}}}{\sig{}}{\movervec[i]{\phih{}}}{\sh{}}} & \mathrm{true} & \\
\ifpath
  \nooverlap
  {\consty{\t{}}{\sig{}}}
  {\proctype{\movervec[i]{\ups{a}}}{\ups{r}}{\movervec[i]{\phih{}}}{\sh{}}} & 
  \mathrm{true} & \\
\fi
  \nooverlap{(\usymsmall\ \overvec{\t{}})}{\sig{}} & \bigwedge
  \overvec{\nooverlap{\t{}}{\sig{}}} & \\
  \nooverlap{\t{}}{\sig{}} & \mathrm{true} & \text{ if } \nooverlap{\sig{}}{\t{}}\\
  \nooverlap{\t{}}{\sig{}} & \mathrm{false} & \text{ otherwise}\\
\end{array}
$$


\newpage
\section{Examples}

\subsection{Expression Examples}

\newcommand{\nump}[1]{\ma{\comb{\numberp}{#1}}}

\newcommand{\carx}{\ma{\comb{\car}{\x{ }}}}

\newcommand{\pecarx}{\ma{\pecar(\x{})}}
\newcommand{\pecarcarx}{\ma{\pecar(\pecar(\x{}))}}

\newcommand{\xenv}[1]{\x{}:{#1}}
\newcommand{\xenvtop}{\xenv{\topty}}
\newcommand{\xyenv}{\xenvtop,\y{}:\topty}


\newcommand{\numpx}{\nump{\x{}}}
\newcommand{\boolpx}{\comb{\boolp}{\x{}}}
\newcommand{\boolpy}{\comb{\boolp}{\y{}}}

\newcommand{\cand}[2]{\comb{\andsym}{{#1}\ {#2}}}
\newcommand{\cor}[2]{\comb{\orsym}{{#1}\ {#2}}}

\newcommand{\numbool}{{(\usym\ \num\ \bool)}}
\newcommand{\inumbool}{{(\isym\ \num\ \bool)}}


\begin{displaymath}
  \hastyvar[\xenvtop]{\x{}}{\topty}{\x{}}
\end{displaymath}

\begin{displaymath}
  \hastyvar[{\xenv{\consty{\topty}{\topty}}{}}]{\carx{}}{\topty}{\pecarx{}}
\end{displaymath}

\begin{displaymath}
  \hastypred [\xenvtop] {\numpx} {\num} {\x{}}
\end{displaymath}

\begin{displaymath}
  \hastypred [\xenv{\consty{\topty}{\topty}}] {\nump{\carx}} {\num} {\pecarx}
\end{displaymath}

\begin{displaymath}
  \hastyfalse[\empty]{\ff}{\fft}
\end{displaymath}

\begin{displaymath}
  \hastytrue[\empty]{3}{\num}
\end{displaymath}

\begin{displaymath}
  \hastyeff[\xyenv] {\cand{\numpx}{\boolpy}} {\bool} {\num_{x{}},\bool_{\y{}}}  {\bullet} {\noeffect}
\end{displaymath}

\begin{displaymath}
  \hastyeff[\xyenv] {\cor{\numpx}{\boolpy}} {\bool} {\bullet} {\comp{\num}_{x{}},\comp{\bool}_{\y{}}}  {\noeffect}
\end{displaymath}

\begin{displaymath}
  \hastyeff[\xenvtop] {\cand{\numpx}{\boolpx}} {\bool} {\num_{x{}},\bool_{\x{}}}  {\bullet} {\noeffect}
\end{displaymath}

\begin{displaymath}
  \hastypred[\xenvtop] {\cor{\numpx}{\boolpx}} {\numbool} {\x{}}
\end{displaymath}

or alternatively, if we had intersection types:

\begin{displaymath}
  \hastypred[\xenvtop] {\cand{\numpx}{\boolpx}} {\inumbool} {\x{}}
\end{displaymath}

\newpage

\subsection{Function Examples}

\newcommand{\consab}{\consty{\a{}}{\b{}}}

\begin{displaymath}
  \hastytrue {\car} {\latentvarty{\consab}{\a{}}{\pecar}{\pecar(0)}}
\end{displaymath}

\begin{displaymath}
  \hastytrue{\abssingle{\x{}}{\a{}}{\x{}}} {\latentvarty{\a{}}{\a{}}{\bullet}{0}}
\end{displaymath}

\begin{displaymath}
  \hastytrue {\numberp} {\predty{\bullet}{\num}}
\end{displaymath}

\begin{displaymath}
  \hastytrue {\abssingle{\x{}}{\topty}{\nump{\x{}}}} {\predty{\bullet}{\num}}
\end{displaymath}

\begin{displaymath}
  \hastytrue {\abssingle{\x{}}{\consab}{\nump{\carx}}} {\predty[{\consab}]{\pecar}{\num}}
\end{displaymath}

\begin{displaymath}
  \hastytrue {\abssingle{\x{}} {\consab} {\nott{\nump{\carx}}}}
  {\proctype{{\consab}}{\bool}{{\comp{\num}_{\pecar}|{{\num}}_{\pecar}}}{\noeffect}}
\end{displaymath}

\begin{displaymath}
  \hastytrue {\abssingle{\x{}}{\a{}}{\ff}} {\proctype{\a{}}{\bool}{\both|\bullet}{\noeffect}}
\end{displaymath}


\ifmarg
\begin{displaymath}
  \hastytrue
  {\absgeneral {\x{} : \topty, \y{} : \topty} {\nump{\x{}}}} 
  {\proctype{\topty, \topty}{\bool}{{\num}_{\bullet}|{\comp{\num}}_{\bullet},\bullet|\bullet}{\noeffect}}
\end{displaymath}
\else
\fi

\newpage

\section{Larger Example}

\def\prty{\consty{\consty{\topty}{\topty}}{\topty}}
\def\prtyf{\consty{\consty{\fft}{\topty}}{\topty}}
\def\env{\x{}:\prty}
\def\app{\comb{\car}{\carx}}
\def\concl{\hastyeffphi{\cond{\app}{\tt}{\app}}{\bool}{\bullet|\bullet}{\noeffect}}



Let $\Gamma = \env$.

\vspace{1cm}

%begin{turn}{270}

\small
$
\inferrule*
{
  \framebox{\(\inferrule*{
      \inferrule*{\hastyvar{\x{}}{\prty}{\x{}}}{\hastyvar{\carx}{\consty{\topty}{\topty}}{\pecarx}}}
    {\hastyvar{\app}{\topty}{\pecarcarx}}\)
  }
\and
\framebox{\(
\inferrule*{
  {\framebox{\(
      \inferrule*
      {\hastytrue[{\x{}:\prtyf}]{\x{}}{\prtyf}}
      {\hastytrue[{\x{}:\prtyf}]{\carx}{\consty{\topty}{\fft}}} \)}}\\\\
  \Gamma + {{\fft}_{\pecarcarx}} = {\x{}:\prtyf} }
 {\hastyfalse[\Gamma + {{\fft}}_{\pecarcarx}]{\app}{\fft}}\)} \\
 \hastytrue[\Gamma + \comp{\fft}_{\pecarcarx}]{\tt}{\ttt} \\
 {\bullet|\bullet} = \combfilter{\fft_{\pecarcarx}|{\comp{\fft}}_{\pecarcarx}}{\bullet|\bot}{\bot|\bullet}}
{\concl}
$
%end{turn}

\normalsize

\newpage

\section{Theorems and Proofs}

% \subsection{Preliminary Definitions}

% \[
% \inferrule{
% \forall \G{}. \forall \x{} \in \mbox{dom}(\G{}). \subtype{(\G{} + \pp{})(x)}{(\G{} + \p{})(x)}
% }
% {
%   \vdash \p{} < \pp{}
% }
% \]

% \[
% \consty{\t{}}{\sig{}} @ \pecar :: \pi = \t{} @ \pi
% \qquad
% \consty{\t{}}{\sig{}} @ \pecdr :: \pi = \sig{} @ \pi
% \qquad
% \t{} @ \epsilon = \t{}
% \]

% \[
% \hastype{\x{}}{\t{}} \models \bot
% \qquad
% \inferrule{\subtype{\t{}' @ \pi}{\t{}}}
% {\hastype{\x{}}{\t{}'} \models \t{\wpi{\x{}}}}
% \qquad
% \inferrule{\notsubtype{\t{}' @ \pi}{\t{}}}
% {\hastype{\x{}}{\t{}'} \models \compt{\wpi{\x{}}}}
% \]
% \[
% \inferrule{\x{} \neq \y{}}
% {\hastype{\x{}}{\t{}'} \models \t{\wpi{\y{}}}}
% \qquad
% \inferrule{\x{} \neq \y{}}
% {\hastype{\x{}}{\t{}'} \models \compt{\wpi{\y{}}}}
% \]

% Note that we can use $\notsubtype{\t{}' @ \pi}{\t{}}$ instead of the
% ``overlap'' relation since everything is a value.

% \subsection{Substitution Lemma}

% If \hastyeffphi [\G{},{\movervec[i]{\hastype{\x{}}{\sig{}}}}] {\e{}} {\t{}} {\p{+} | \p{-}} {\s{}}

% \noindent
% and \hastyeffphi [] {\vv{}} {\sig{}'} {\phii{0}} {\s{0}}

% \noindent
% and \subtype{\sig{}'}{\sig{}}

% \noindent
% Then $\hastyeffphi {\subs{\e{}} {\x{}} {\vv{}}} {\t{}'} {\pp{+} | \pp{-}} {\s{}'}$

% \noindent
% and \subtype{\t{}'}{\t{}}

% \noindent
% and $\hastype{\x{}}{\sig{}'} \models \p{\pm} \quad \Rightarrow \quad \vdash \pp{\pm} < \p{\pm}$


% \noindent
% and $\hastype{\x{}}{\sig{}'} \not\models \p{\pm} \quad \Rightarrow \quad \pp{\pm} = \bot$

% \noindent
% and either $\s{} = \wpi{\x{}} \wedge \s{}' = \noeffect$ or $\s{} = \s{}'$
 

\subsection{Typing for Closures}

\[
\inferrule[T-Clos]{\exists \G{}. \rho \models \G{} \text{ and }
  \hastyeffphi{\abs{\x{}}{\t{}}{\e{}}}{\sig{}}{\phii{}}{\s{}}}
{\hastyeffphi[]{\clos{\rho}{\abs{\x{}}{\t{}}{\e{}}}}{\sig{}}{\phii{}}{\s{}}}
\]

\subsection{Environment Modeling}

\[
\inferrule{\hastyeffphi[\relax{}]{\rho(\wpi{\x{}})}{\sig{}}{\phii}{\s{}} \\\\
  \subtype{\sig{}}{\t{}}}{\rho \models \t{\wpi{x{}}}}
\qquad\qquad
\inferrule{\hastyeffphi[\relax{}]{\rho(\wpi{\x{}})}{\sig{}}{\phii}{\s{}}
\\\\  \nooverlap{\sig{}}{\t{}}}{\rho \models \comp{\t{}}_{\wpi{x{}}}}
\qquad\qquad
\inferrule{}{\rho \models \top}
\]
\[
\inferrule{\rho \models \p1 \text{ or } \rho \models \p2}{\rho \models \p1 \vee \p2}
\qquad\qquad
\inferrule{\rho \models \p{} \Rightarrow \rho \models
  \p{}'}{\rho \models \imp{\p{}}{\p{}'}}
\qquad\qquad
\inferrule{\rho \models \p{} \\ \rho \models
  \p{}'}{\rho \models {\p{}} \wedge {\p{}'}}
\]


\subsection{Lemmas}

\begin{lemma}[Soundness of Derivations]
If $\rho \models \G{}$ and $\G{} \vdash P$ then $\rho \models P$.
\label{lem:mod-concl}
\end{lemma}

\begin{lemma}[Soundness]
If $\hastyeff{\e{}}{\t{}}{\p{+}}{\p{-}}{\s{}}$ and $\rho \models
\G{}$ and $\evalprime{\e{}}{\vv{}}$ then

\begin{enumerate}
\item Either $\s{} = \noeffect$ or $\rho(\s{}) = \vv{}$.
\item Either $\vv{} \neq \ff$ and $\rho \models
\p{+}$ or $\vv{} = \ff$ and $\rho \models
\p{-}$.
\item $\hastyeff[]{\vv{}}{\t{}'}{\p{+}'}{\p{-}'}{\s{}'}$ where
$\subtype{\t{}'}{\t{}}$. 
\end{enumerate}
\end{lemma}

\noindent
{\bf Proof:}
By induction and cases on the derivation of
$\hastyeff{\e{}}{\t{}}{\p{+}}{\p{-}}{\s{}}$.

\noindent
Cases:
\begin{enumerate}
\item {\sc T-Bot}.  By assumption, $\rho \models \G{}$, and therefore
  $\rho \models \bot$ by lemma~\ref{lem:mod-concl}.  But $\rho \not\models
\bot$ by inspection of the rules.  
\item {\sc T-Num}.  First, $\s{} = \noeffect$.  Second, $e = n$ and
  therefore by {\sc B-Val} (the only rule that applies), $v = n$.
  Thus, $\t{} = \t{}'$ and the
  third requirement is discharged.  Finally, $\p{+} = \epsilon$ and
  $\rho \models \top$ for any $\rho$.
\item {\sc T-Const, T-True, T-False}. Similar to {\sc T-Num}.
\item {\sc T-Cons}. First, $\s{} = \noeffect$.  Second, $\e{} =
  \cons{\e1}{\e2}$ and $\t{} = \consty{\t1}{\t2}$.  Third, by {\sc
    B-Cons}, the only applicable rule, $\evaltwo{\rho}{\e1}{\rho_1}{\vv1}$ and
  $\evaltwo{\rho}{\e2}{\rho'}{\vv2}$.  By the induction hypothesis,
  we have 
  $\hastyeff[\Gamma]{\vv1}{\t{1}'}{\pp{1+}}{\pp{1-}}{\s{1}'}$  and
  $\hastyeff[\Gamma]{\vv2}{\t{2}'}{\pp{2+}}{\pp{2-}}{\s{2}'}$ and
  \subtype{\t1'}{\t1} and \subtype{\t2'}{\t2}.
  Thus
  $\hastyeff[\Gamma]{\cons{\vv{1}}{\vv2}}{\consty{\t{1}'}{\t2'}}{\epsilon}{\bot}{\noeffect}$
  concluding part 3.  For part 2, note that $\cons{\vv{1}}{\vv2} \neq
  \ff$ and $\rho \models \epsilon$.
\item {\sc T-Var}.  The only applicable evaluation rule is {\sc
    B-Var}.  Therefore, $\vv{} = \rho(\x{})$, making part 1 trivial,
  since $\s{} = \x{}$. For part 2, assume $\vv{} \neq \ff$.  Then we
  must show that $\rho \models \comp{\fft}_{\x{}}$.  Since $\vv{} \neq
  \ff$, $\vv{}$ must be some other value, which is either $\tt$, a
  pair, or a closure.  In each case, we know that $\vv{}$ can be given
  a type $\sig{}$ such that $\nooverlap{\sig{}}{\fft}$, as desired.
  If $\vv{} = \ff$, then $\rho(\x{}) = \ff$ and part 2 is trivial.
  For part 3, we have that $\G{} \vdash \t{\x{}}$, and therefore that
  $\rho \models \t{\x{}}$.  Thus,
  $\hastyeffphi[]{\vv{}}{\t{}'}{\phii{}}{\s{}'}$ for some $\t{}'$
  where $\subtype{\t{}'}{\t{}}$.
\item {\sc T-Not}. Easy application of the induction hypothesis.
\item {\sc T-If}. Easy application of the induction hypothesis.
\item {\sc T-Car}. There are two possible cases.  If the argument has
  object $\noeffect$, then the resulting filter set is $\top|\top$ and
  the resulting object is $\noeffect$.  The resulting value must be of
  the correct type by application of the IH and the fact that the
  final evaluation rule must be {\sc T-Delta}. 

  If the argument has
  object $\pi(\x{})$, then the resulting object is $\pecar(\pi(\x{}))$
  and the resulting filter set is $\fft_{\pecar(\pi(\x{}))}|\comp{\fft}_{\pecar(\pi(\x{}))}$.
\item {\sc T-Cdr}. Similar to {\sc T-Car}.
\item {\sc T-Let}. ???
\item {\sc T-App}. ???
\item {\sc T-Abs}. Like {\sc T-Num}.  Does this mean I need a stronger IH?
\end{enumerate}
\qed 

\end{document}

